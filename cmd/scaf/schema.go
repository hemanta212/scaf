package main

import (
	"context"
	"fmt"
	"os"
	"sort"

	"github.com/rlch/scaf"
	"github.com/urfave/cli/v3"

	// Register databases.
	_ "github.com/rlch/scaf/databases/neo4j"
)

func schemaCommand() *cli.Command {
	return &cli.Command{
		Name:      "schema",
		Usage:     "Extract schema from database",
		ArgsUsage: "[output-file]",
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:    "config",
				Aliases: []string{"c"},
				Usage:   "path to .scaf.yaml config file",
			},
			&cli.StringFlag{
				Name:    "output",
				Aliases: []string{"o"},
				Usage:   "output file (default: .scaf-schema.yaml)",
				Value:   ".scaf-schema.yaml",
			},
		},
		Action: func(ctx context.Context, cmd *cli.Command) error {
			// Find config
			configPath := cmd.String("config")
			if configPath == "" {
				var err error
				configPath, err = scaf.FindConfig(".")
				if err != nil {
					return fmt.Errorf("no config found: %w", err)
				}
			}

			// Load config
			cfg, err := scaf.LoadConfig(configPath)
			if err != nil {
				return fmt.Errorf("failed to load config: %w", err)
			}

			// Create database connection
			db, err := cfg.CreateDatabase()
			if err != nil {
				return fmt.Errorf("failed to connect to database: %w", err)
			}
			defer db.Close()

			// Check if database supports introspection
			introspector, ok := db.(scaf.SchemaIntrospector)
			if !ok {
				return fmt.Errorf("database %s does not support schema introspection", db.Name())
			}

			// Extract schema
			fmt.Fprintf(os.Stderr, "Extracting schema from %s...\n", db.Name())
			schema, err := introspector.IntrospectSchema(ctx)
			if err != nil {
				return fmt.Errorf("failed to extract schema: %w", err)
			}

			// Generate YAML output
			output := cmd.String("output")
			if cmd.Args().Len() > 0 {
				output = cmd.Args().First()
			}

			if err := writeSchemaYAML(schema, output); err != nil {
				return fmt.Errorf("failed to write schema: %w", err)
			}

			fmt.Fprintf(os.Stderr, "Schema written to %s\n", output)
			return nil
		},
	}
}

func writeSchemaYAML(schema *scaf.Schema, path string) error {
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	// Write header
	fmt.Fprintln(f, "# yaml-language-server: $schema=https://raw.githubusercontent.com/rlch/scaf/refs/heads/master/.scaf-type.schema.json")
	fmt.Fprintln(f, "# Auto-generated by: scaf schema")
	fmt.Fprintln(f)

	// Sort model names for consistent output
	names := make([]string, 0, len(schema.Models))
	for name := range schema.Models {
		names = append(names, name)
	}
	sort.Strings(names)

	// Write models
	fmt.Fprintln(f, "models:")
	for _, name := range names {
		model := schema.Models[name]
		fmt.Fprintf(f, "  %s:\n", name)

		if len(model.Fields) > 0 {
			fmt.Fprintln(f, "    fields:")

			// Sort field names
			fieldNames := make([]string, 0, len(model.Fields))
			for fn := range model.Fields {
				fieldNames = append(fieldNames, fn)
			}
			sort.Strings(fieldNames)

			for _, fn := range fieldNames {
				field := model.Fields[fn]
				fmt.Fprintf(f, "      %s:\n", fn)
				fmt.Fprintf(f, "        type: %s\n", field.Type)
				fmt.Fprintf(f, "        required: %t\n", field.Required)
			}
		}

		if len(model.Relationships) > 0 {
			fmt.Fprintln(f, "    relationships:")
			for rn, rel := range model.Relationships {
				fmt.Fprintf(f, "      %s:\n", rn)
				fmt.Fprintf(f, "        rel_type: %s\n", rel.RelType)
				fmt.Fprintf(f, "        target: %s\n", rel.Target)
				fmt.Fprintf(f, "        many: %t\n", rel.Many)
				fmt.Fprintf(f, "        direction: %s\n", rel.Direction)
			}
		}

		// Empty model (relationship type)
		if len(model.Fields) == 0 && len(model.Relationships) == 0 {
			fmt.Fprintln(f, "    {}")
		}

		fmt.Fprintln(f)
	}

	return nil
}
