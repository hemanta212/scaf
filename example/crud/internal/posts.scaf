// Post CRUD operations - imports users fixtures
import fixtures "./fixtures"

fn CreatePost(id, title, content, authorId, createdAt) `
MATCH (u:User {id: $authorId})
CREATE (p:Post {id: $id, title: $title, content: $content, createdAt: $createdAt})
CREATE (u)-[:AUTHORED]->(p)
RETURN p.id, p.title, p.content
`

fn GetPostById(id) `
MATCH (p:Post {id: $id})
OPTIONAL MATCH (author:User)-[:AUTHORED]->(p)
RETURN p.id, p.title, p.content, author.name as authorName
`

fn GetPostsByAuthor(authorId) `
MATCH (u:User {id: $authorId})-[:AUTHORED]->(p:Post)
RETURN p.id, p.title, p.content
ORDER BY p.createdAt DESC
`

fn ListPosts() `
MATCH (p:Post)
OPTIONAL MATCH (author:User)-[:AUTHORED]->(p)
RETURN p.id, p.title, author.name as authorName
ORDER BY p.createdAt DESC
`

fn UpdatePost(id, title, content) `
MATCH (p:Post {id: $id})
SET p.title = $title, p.content = $content
RETURN p.id, p.title, p.content
`

fn DeletePost(id) `
MATCH (p:Post {id: $id})
DETACH DELETE p
RETURN count(p) as deleted
`

fn CountPosts() `
MATCH (p:Post)
RETURN count(p) as count
`

fn CountRelationships() `
MATCH ()-[r:AUTHORED]->()
RETURN count(r) as count
`

fn LikePost(userId, postId) `
MATCH (u:User {id: $userId}), (p:Post {id: $postId})
MERGE (u)-[l:LIKED]->(p)
ON CREATE SET l.createdAt = timestamp()
RETURN count(l) as liked
`

fn GetPostLikes(postId) `
MATCH (u:User)-[:LIKED]->(p:Post {id: $postId})
RETURN count(u) as likeCount, collect(u.name) as likers
`

fn HasLiked(userId, postId) `
MATCH (u:User {id: $userId})-[:LIKED]->(p:Post {id: $postId})
RETURN count(*) > 0 as hasLiked
`

setup {
	fixtures
	fixtures.CreateUsers()
	fixtures.CreatePosts()
}
teardown `MATCH (n) DETACH DELETE n`

GetPostById {
	group "existing posts" {
		test "finds post with author" {
			$id: 1

			p.title: "Hello World"
			authorName: "Alice"

			assert (p.title != "")
		}
	}

	group "non-existent posts" {
		test "returns null for non-existent post" {
			$id: 999

			p.id: null
			p.title: null
		}
	}
}

GetPostsByAuthor {
	group "users with posts" {
		test "gets Alice's posts" {
			$authorId: 1

			p.title: "Learning Neo4j"
		}

		test "gets Bob's posts" {
			$authorId: 2

			p.title: "Bob's Post"
		}
	}
}

CountPosts {
	test "counts all posts" {
		count: 3
	}
}

CountRelationships {
	test "has authored relationships" {
		count: 3
	}
}

CreatePost {
	group "valid creation" {
		test "creates post linked to author" {
			$id: 10
			$title: "New Post"
			$content: "Some content here"
			$authorId: 1
			$createdAt: 1700001000

			p.id: 10
			p.title: "New Post"
		}
	}
}

UpdatePost {
	group "valid updates" {
		test "updates post title and content" {
			$id: 1
			$title: "Hello World (Updated)"
			$content: "Updated content"

			p.title: "Hello World (Updated)"
			p.content: "Updated content"
		}
	}
}

DeletePost {
	group "existing posts" {
		test "deletes existing post" {
			$id: 3

			deleted: 1

			assert `MATCH (p:Post {id: 3}) RETURN count(p) as c` {
				(c == 0)
			}
		}
	}
}

ListPosts {
	test "lists all posts with authors" {
		p.title: "Bob's Post"
		authorName: "Bob"
	}
}

LikePost {
	group "liking behavior" {
		test "user can like a post" {
			$userId: 2
			$postId: 1

			liked: 1

			assert HasLiked(userId: 2, postId: 1) {
				(hasLiked != nil)
			}
		}

		test "like is idempotent (MERGE)" {
			setup `
			MATCH (u:User {id: 2}), (p:Post {id: 1})
			CREATE (u)-[:LIKED]->(p)
			`

			$userId: 2
			$postId: 1

			liked: 1
		}
	}
}

GetPostLikes {
	group "with likes" {
		setup `
		MATCH (bob:User {id: 2}), (p1:Post {id: 1})
		CREATE (bob)-[:LIKED]->(p1)
		`

		test "returns like count and likers" {
			$postId: 1

			likeCount: 1

			assert ("Bob" in likers)
		}
	}

	group "no likes" {
		test "returns zero count for unliked post" {
			$postId: 2

			likeCount: 0
		}
	}
}
