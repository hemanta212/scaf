// Tweet-like posts with likes
import fixtures "./fixtures"

fn CreatePost(id, authorId, content, createdAt) `
MATCH (u:User {id: $authorId})
CREATE (p:Post {id: $id, content: $content, createdAt: $createdAt})
CREATE (u)-[:AUTHORED]->(p)
RETURN p.id, p.content, u.name as authorName
`

fn GetPost(id) `
MATCH (u:User)-[:AUTHORED]->(p:Post {id: $id})
RETURN p.id, p.content, p.createdAt, u.id as authorId, u.name as authorName
`

fn GetUserPosts(userId) `
MATCH (u:User {id: $userId})-[:AUTHORED]->(p:Post)
RETURN p.id, p.content, p.createdAt
ORDER BY p.createdAt DESC
`

fn DeletePost(id) `
MATCH (p:Post {id: $id})
DETACH DELETE p
RETURN count(p) as deleted
`

fn LikePost(userId, postId) `
MATCH (u:User {id: $userId}), (p:Post {id: $postId})
MERGE (u)-[l:LIKED]->(p)
ON CREATE SET l.createdAt = timestamp()
RETURN count(l) as liked
`

fn GetPostLikes(postId) `
MATCH (u:User)-[:LIKED]->(p:Post {id: $postId})
RETURN count(u) as likeCount, collect(u.name) as likers
`

fn CountUserPosts(userId) `
MATCH (u:User {id: $userId})-[:AUTHORED]->(p:Post)
RETURN count(p) as count
`

fn HasLiked(userId, postId) `
MATCH (u:User {id: $userId})-[:LIKED]->(p:Post {id: $postId})
RETURN count(*) > 0 as hasLiked
`

setup {
	fixtures
	fixtures.CreateUsers()
	fixtures.CreatePosts()
}
teardown `MATCH (n) DETACH DELETE n`

GetPost {
	group "existing posts" {
		test "finds post with author info" {
			$id: 1

			p.id: 1
			p.content: "Hello World"
			authorName: "Alice"
			authorId: 1

			assert (p.content != "")
		}

		test "validates content format" {
			$id: 2

			p.content: "Learning Neo4j"

			assert (p.content != "")
		}
	}

	group "edge cases" {
		test "non-existent post returns null" {
			$id: 999
			p.id: null
			p.content: null
		}
	}
}

CreatePost {
	group "valid creation" {
		test "creates post and links to author" {
			$id: 100
			$authorId: 1
			$content: "My new tweet!"
			$createdAt: 1700001000

			p.id: 100
			p.content: "My new tweet!"
			authorName: "Alice"

			assert CountUserPosts(userId: 1) {
				(count != nil)
			}
		}
	}

	group "validation" {
		test "creates empty content post" {
			setup `CREATE (:ValidationTest {id: 999})`

			$id: 101
			$authorId: 1
			$content: ""
			$createdAt: 1700001001

			p.id: 101
		}
	}
}

LikePost {
	group "liking behavior" {
		test "user can like a post" {
			$userId: 2
			$postId: 1

			liked: 1

			assert HasLiked(userId: 2, postId: 1) {
				(hasLiked != nil)
			}
		}

		test "like is idempotent (MERGE)" {
			setup `
			MATCH (u:User {id: 2}), (p:Post {id: 1})
			CREATE (u)-[:LIKED]->(p)
			`

			$userId: 2
			$postId: 1

			liked: 1
		}
	}
}

GetPostLikes {
	group "with likes" {
		setup `
		MATCH (bob:User {id: 2}), (p1:Post {id: 1})
		CREATE (bob)-[:LIKED]->(p1)
		`

		test "returns like count and likers" {
			$postId: 1

			likeCount: 1

			assert ("Bob" in likers)
		}
	}

	group "no likes" {
		test "returns zero count for unliked post" {
			$postId: 2

			likeCount: 0
		}
	}
}

GetUserPosts {
	group "user with posts" {
		test "returns posts ordered by createdAt desc" {
			$userId: 1

			p.id: 2

			assert (p.content != nil)
		}
	}

	group "user without posts" {
		test "returns empty for user with no posts" {
			$userId: 3

			p.id: null
		}
	}
}

DeletePost {
	group "existing posts" {
		test "deletes existing post" {
			$id: 3

			deleted: 1

			assert `MATCH (p:Post {id: 3}) RETURN count(p) as c` {
				(c == 0)
			}
		}
	}

	group "non-existent posts" {
		test "delete non-existent post returns 0" {
			$id: 999
			deleted: 0
		}
	}
}
