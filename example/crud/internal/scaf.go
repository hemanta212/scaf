// Code generated by scaf. DO NOT EDIT.

package internal

import (
	"context"
	"github.com/rlch/neogo"
)

type createCommentResult struct {
	ID int
	Text string
}

type getCommentByIdResult struct {
	ID int
	Text string
	AuthorName string
	PostTitle string
}

type getCommentsByPostResult struct {
	ID int
	Text string
	AuthorName string
}

type getCommentsByUserResult struct {
	ID int
	Text string
	PostTitle string
}

type updateCommentResult struct {
	ID int
	Text string
}

type createReplyResult struct {
	ID int
	Text string
}

type getRepliesResult struct {
	ID int
	Text string
	AuthorName string
}

type createPostResult struct {
	ID int
	Title string
	Content string
}

type getPostByIdResult struct {
	ID int
	Title string
	Content string
	AuthorName string
}

type getPostsByAuthorResult struct {
	ID int
	Title string
	Content string
}

type listPostsResult struct {
	ID int
	Title string
	AuthorName string
}

type updatePostResult struct {
	ID int
	Title string
	Content string
}

type createUserResult struct {
	ID int
	Name string
	Email string
}

type getUserByIdResult struct {
	ID int
	Name string
	Email string
	CreatedAt int
}

type getUserByEmailResult struct {
	ID int
	Name string
	Email string
}

type listUsersResult struct {
	ID int
	Name string
	Email string
}

type updateUserResult struct {
	ID int
	Name string
	Email string
}

func CreateComment(ctx context.Context, db neogo.Driver, authorId int, postId int, id int, text string, createdAt int) ([]*createCommentResult, error) {
	return createCommentImpl(ctx, db, authorId, postId, id, text, createdAt)
}

var createCommentImpl func(context.Context, neogo.Driver, int, int, int, string, int) ([]*createCommentResult, error) = createCommentProd

func createCommentProd(ctx context.Context, db neogo.Driver, authorId int, postId int, id int, text string, createdAt int) ([]*createCommentResult, error) {
	var rowsID []int
	var rowsText []string
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $authorId}), (p:Post {id: $postId})
	CREATE (c:Comment {id: $id, text: $text, createdAt: $createdAt})
	CREATE (u)-[:WROTE]->(c)
	CREATE (p)-[:HAS]->(c)
	RETURN c.id, c.text`).
		RunWithParams(ctx, map[string]any{"authorId": authorId, "postId": postId, "id": id, "text": text, "createdAt": createdAt}, "c.id", &rowsID, "c.text", &rowsText)
	if err != nil {
		return nil, err
	}
	results := make([]*createCommentResult, len(rowsID))
	for i := range rowsID {
		results[i] = &createCommentResult{
			ID: rowsID[i],
			Text: rowsText[i],
		}
	}
	return results, nil
}

func GetCommentById(ctx context.Context, db neogo.Driver, id int) ([]*getCommentByIdResult, error) {
	return getCommentByIdImpl(ctx, db, id)
}

var getCommentByIdImpl func(context.Context, neogo.Driver, int) ([]*getCommentByIdResult, error) = getCommentByIdProd

func getCommentByIdProd(ctx context.Context, db neogo.Driver, id int) ([]*getCommentByIdResult, error) {
	var rowsID []int
	var rowsText []string
	var rowsAuthorName []string
	var rowsPostTitle []string
	err := db.Exec().
		Cypher(`MATCH (c:Comment {id: $id})
	OPTIONAL MATCH (author:User)-[:WROTE]->(c)
	OPTIONAL MATCH (post:Post)-[:HAS]->(c)
	RETURN c.id, c.text, author.name as authorName, post.title as postTitle`).
		RunWithParams(ctx, map[string]any{"id": id}, "c.id", &rowsID, "c.text", &rowsText, "authorName", &rowsAuthorName, "postTitle", &rowsPostTitle)
	if err != nil {
		return nil, err
	}
	results := make([]*getCommentByIdResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getCommentByIdResult{
			ID: rowsID[i],
			Text: rowsText[i],
			AuthorName: rowsAuthorName[i],
			PostTitle: rowsPostTitle[i],
		}
	}
	return results, nil
}

func GetCommentsByPost(ctx context.Context, db neogo.Driver, postId int) ([]*getCommentsByPostResult, error) {
	return getCommentsByPostImpl(ctx, db, postId)
}

var getCommentsByPostImpl func(context.Context, neogo.Driver, int) ([]*getCommentsByPostResult, error) = getCommentsByPostProd

func getCommentsByPostProd(ctx context.Context, db neogo.Driver, postId int) ([]*getCommentsByPostResult, error) {
	var rowsID []int
	var rowsText []string
	var rowsAuthorName []string
	err := db.Exec().
		Cypher(`MATCH (p:Post {id: $postId})-[:HAS]->(c:Comment)
	OPTIONAL MATCH (author:User)-[:WROTE]->(c)
	RETURN c.id, c.text, author.name as authorName
	ORDER BY c.createdAt ASC`).
		RunWithParams(ctx, map[string]any{"postId": postId}, "c.id", &rowsID, "c.text", &rowsText, "authorName", &rowsAuthorName)
	if err != nil {
		return nil, err
	}
	results := make([]*getCommentsByPostResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getCommentsByPostResult{
			ID: rowsID[i],
			Text: rowsText[i],
			AuthorName: rowsAuthorName[i],
		}
	}
	return results, nil
}

func GetCommentsByUser(ctx context.Context, db neogo.Driver, userId int) ([]*getCommentsByUserResult, error) {
	return getCommentsByUserImpl(ctx, db, userId)
}

var getCommentsByUserImpl func(context.Context, neogo.Driver, int) ([]*getCommentsByUserResult, error) = getCommentsByUserProd

func getCommentsByUserProd(ctx context.Context, db neogo.Driver, userId int) ([]*getCommentsByUserResult, error) {
	var rowsID []int
	var rowsText []string
	var rowsPostTitle []string
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $userId})-[:WROTE]->(c:Comment)
	OPTIONAL MATCH (p:Post)-[:HAS]->(c)
	RETURN c.id, c.text, p.title as postTitle
	ORDER BY c.createdAt DESC`).
		RunWithParams(ctx, map[string]any{"userId": userId}, "c.id", &rowsID, "c.text", &rowsText, "postTitle", &rowsPostTitle)
	if err != nil {
		return nil, err
	}
	results := make([]*getCommentsByUserResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getCommentsByUserResult{
			ID: rowsID[i],
			Text: rowsText[i],
			PostTitle: rowsPostTitle[i],
		}
	}
	return results, nil
}

func UpdateComment(ctx context.Context, db neogo.Driver, id int, text string) ([]*updateCommentResult, error) {
	return updateCommentImpl(ctx, db, id, text)
}

var updateCommentImpl func(context.Context, neogo.Driver, int, string) ([]*updateCommentResult, error) = updateCommentProd

func updateCommentProd(ctx context.Context, db neogo.Driver, id int, text string) ([]*updateCommentResult, error) {
	var rowsID []int
	var rowsText []string
	err := db.Exec().
		Cypher(`MATCH (c:Comment {id: $id})
	SET c.text = $text
	RETURN c.id, c.text`).
		RunWithParams(ctx, map[string]any{"id": id, "text": text}, "c.id", &rowsID, "c.text", &rowsText)
	if err != nil {
		return nil, err
	}
	results := make([]*updateCommentResult, len(rowsID))
	for i := range rowsID {
		results[i] = &updateCommentResult{
			ID: rowsID[i],
			Text: rowsText[i],
		}
	}
	return results, nil
}

func DeleteComment(ctx context.Context, db neogo.Driver, id int) ([]int, error) {
	return deleteCommentImpl(ctx, db, id)
}

var deleteCommentImpl func(context.Context, neogo.Driver, int) ([]int, error) = deleteCommentProd

func deleteCommentProd(ctx context.Context, db neogo.Driver, id int) ([]int, error) {
	var rowsDeleted []int
	err := db.Exec().
		Cypher(`MATCH (c:Comment {id: $id})
	DETACH DELETE c
	RETURN count(c) as deleted`).
		RunWithParams(ctx, map[string]any{"id": id}, "deleted", &rowsDeleted)
	if err != nil {
		return nil, err
	}
	return rowsDeleted, nil
}

func CountCommentsByPost(ctx context.Context, db neogo.Driver, postId int) ([]int, error) {
	return countCommentsByPostImpl(ctx, db, postId)
}

var countCommentsByPostImpl func(context.Context, neogo.Driver, int) ([]int, error) = countCommentsByPostProd

func countCommentsByPostProd(ctx context.Context, db neogo.Driver, postId int) ([]int, error) {
	var rowsCount []int
	err := db.Exec().
		Cypher(`MATCH (p:Post {id: $postId})-[:HAS]->(c:Comment)
	RETURN count(c) as count`).
		RunWithParams(ctx, map[string]any{"postId": postId}, "count", &rowsCount)
	if err != nil {
		return nil, err
	}
	return rowsCount, nil
}

func CreateReply(ctx context.Context, db neogo.Driver, authorId int, parentId int, id int, text string, createdAt int) ([]*createReplyResult, error) {
	return createReplyImpl(ctx, db, authorId, parentId, id, text, createdAt)
}

var createReplyImpl func(context.Context, neogo.Driver, int, int, int, string, int) ([]*createReplyResult, error) = createReplyProd

func createReplyProd(ctx context.Context, db neogo.Driver, authorId int, parentId int, id int, text string, createdAt int) ([]*createReplyResult, error) {
	var rowsID []int
	var rowsText []string
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $authorId}), (parent:Comment {id: $parentId})
	CREATE (c:Comment {id: $id, text: $text, createdAt: $createdAt})
	CREATE (u)-[:WROTE]->(c)
	CREATE (c)-[:REPLIES]->(parent)
	RETURN c.id, c.text`).
		RunWithParams(ctx, map[string]any{"authorId": authorId, "parentId": parentId, "id": id, "text": text, "createdAt": createdAt}, "c.id", &rowsID, "c.text", &rowsText)
	if err != nil {
		return nil, err
	}
	results := make([]*createReplyResult, len(rowsID))
	for i := range rowsID {
		results[i] = &createReplyResult{
			ID: rowsID[i],
			Text: rowsText[i],
		}
	}
	return results, nil
}

func GetReplies(ctx context.Context, db neogo.Driver, commentId int) ([]*getRepliesResult, error) {
	return getRepliesImpl(ctx, db, commentId)
}

var getRepliesImpl func(context.Context, neogo.Driver, int) ([]*getRepliesResult, error) = getRepliesProd

func getRepliesProd(ctx context.Context, db neogo.Driver, commentId int) ([]*getRepliesResult, error) {
	var rowsID []int
	var rowsText []string
	var rowsAuthorName []string
	err := db.Exec().
		Cypher(`MATCH (reply:Comment)-[:REPLIES]->(c:Comment {id: $commentId})
	OPTIONAL MATCH (author:User)-[:WROTE]->(reply)
	RETURN reply.id, reply.text, author.name as authorName
	ORDER BY reply.createdAt ASC`).
		RunWithParams(ctx, map[string]any{"commentId": commentId}, "reply.id", &rowsID, "reply.text", &rowsText, "authorName", &rowsAuthorName)
	if err != nil {
		return nil, err
	}
	results := make([]*getRepliesResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getRepliesResult{
			ID: rowsID[i],
			Text: rowsText[i],
			AuthorName: rowsAuthorName[i],
		}
	}
	return results, nil
}

func CountReplies(ctx context.Context, db neogo.Driver, commentId int) ([]int, error) {
	return countRepliesImpl(ctx, db, commentId)
}

var countRepliesImpl func(context.Context, neogo.Driver, int) ([]int, error) = countRepliesProd

func countRepliesProd(ctx context.Context, db neogo.Driver, commentId int) ([]int, error) {
	var rowsCount []int
	err := db.Exec().
		Cypher(`MATCH (reply:Comment)-[:REPLIES]->(c:Comment {id: $commentId})
	RETURN count(reply) as count`).
		RunWithParams(ctx, map[string]any{"commentId": commentId}, "count", &rowsCount)
	if err != nil {
		return nil, err
	}
	return rowsCount, nil
}

func CreateUsers(ctx context.Context, db neogo.Driver) error {
	return createUsersImpl(ctx, db)
}

var createUsersImpl func(context.Context, neogo.Driver) error = createUsersProd

func createUsersProd(ctx context.Context, db neogo.Driver) error {
	err := db.Exec().
		Cypher(`CREATE (alice:User {id: 1, name: "Alice", email: "alice@example.com", createdAt: 1700000000})
	CREATE (bob:User {id: 2, name: "Bob", email: "bob@example.com", createdAt: 1700000001})
	CREATE (charlie:User {id: 3, name: "Charlie", email: "charlie@example.com", createdAt: 1700000002})`).
		Run(ctx)
	if err != nil {
		return err
	}
	return nil
}

func CreatePosts(ctx context.Context, db neogo.Driver) error {
	return createPostsImpl(ctx, db)
}

var createPostsImpl func(context.Context, neogo.Driver) error = createPostsProd

func createPostsProd(ctx context.Context, db neogo.Driver) error {
	err := db.Exec().
		Cypher(`MATCH (alice:User {id: 1}), (bob:User {id: 2})
	CREATE (p1:Post {id: 1, title: "Hello World", content: "My first post!", createdAt: 1700000100})
	CREATE (p2:Post {id: 2, title: "Learning Neo4j", content: "Graph databases are cool", createdAt: 1700000200})
	CREATE (p3:Post {id: 3, title: "Bob's Post", content: "Hi from Bob", createdAt: 1700000300})
	CREATE (alice)-[:AUTHORED]->(p1)
	CREATE (alice)-[:AUTHORED]->(p2)
	CREATE (bob)-[:AUTHORED]->(p3)`).
		Run(ctx)
	if err != nil {
		return err
	}
	return nil
}

func CreateComments(ctx context.Context, db neogo.Driver) error {
	return createCommentsImpl(ctx, db)
}

var createCommentsImpl func(context.Context, neogo.Driver) error = createCommentsProd

func createCommentsProd(ctx context.Context, db neogo.Driver) error {
	err := db.Exec().
		Cypher(`MATCH (alice:User {id: 1}), (bob:User {id: 2}), (p1:Post {id: 1})
	CREATE (c1:Comment {id: 1, text: "Great post!", createdAt: 1700000150})
	CREATE (c2:Comment {id: 2, text: "Thanks for sharing", createdAt: 1700000160})
	CREATE (c3:Comment {id: 3, text: "I agree!", createdAt: 1700000170})
	CREATE (bob)-[:WROTE]->(c1)
	CREATE (alice)-[:WROTE]->(c2)
	CREATE (bob)-[:WROTE]->(c3)
	CREATE (p1)-[:HAS]->(c1)
	CREATE (p1)-[:HAS]->(c2)
	CREATE (p1)-[:HAS]->(c3)`).
		Run(ctx)
	if err != nil {
		return err
	}
	return nil
}

func CreatePost(ctx context.Context, db neogo.Driver, authorId int, id int, title string, content string, createdAt int) ([]*createPostResult, error) {
	return createPostImpl(ctx, db, authorId, id, title, content, createdAt)
}

var createPostImpl func(context.Context, neogo.Driver, int, int, string, string, int) ([]*createPostResult, error) = createPostProd

func createPostProd(ctx context.Context, db neogo.Driver, authorId int, id int, title string, content string, createdAt int) ([]*createPostResult, error) {
	var rowsID []int
	var rowsTitle []string
	var rowsContent []string
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $authorId})
	CREATE (p:Post {id: $id, title: $title, content: $content, createdAt: $createdAt})
	CREATE (u)-[:AUTHORED]->(p)
	RETURN p.id, p.title, p.content`).
		RunWithParams(ctx, map[string]any{"authorId": authorId, "id": id, "title": title, "content": content, "createdAt": createdAt}, "p.id", &rowsID, "p.title", &rowsTitle, "p.content", &rowsContent)
	if err != nil {
		return nil, err
	}
	results := make([]*createPostResult, len(rowsID))
	for i := range rowsID {
		results[i] = &createPostResult{
			ID: rowsID[i],
			Title: rowsTitle[i],
			Content: rowsContent[i],
		}
	}
	return results, nil
}

func GetPostById(ctx context.Context, db neogo.Driver, id int) ([]*getPostByIdResult, error) {
	return getPostByIdImpl(ctx, db, id)
}

var getPostByIdImpl func(context.Context, neogo.Driver, int) ([]*getPostByIdResult, error) = getPostByIdProd

func getPostByIdProd(ctx context.Context, db neogo.Driver, id int) ([]*getPostByIdResult, error) {
	var rowsID []int
	var rowsTitle []string
	var rowsContent []string
	var rowsAuthorName []string
	err := db.Exec().
		Cypher(`MATCH (p:Post {id: $id})
	OPTIONAL MATCH (author:User)-[:AUTHORED]->(p)
	RETURN p.id, p.title, p.content, author.name as authorName`).
		RunWithParams(ctx, map[string]any{"id": id}, "p.id", &rowsID, "p.title", &rowsTitle, "p.content", &rowsContent, "authorName", &rowsAuthorName)
	if err != nil {
		return nil, err
	}
	results := make([]*getPostByIdResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getPostByIdResult{
			ID: rowsID[i],
			Title: rowsTitle[i],
			Content: rowsContent[i],
			AuthorName: rowsAuthorName[i],
		}
	}
	return results, nil
}

func GetPostsByAuthor(ctx context.Context, db neogo.Driver, authorId int) ([]*getPostsByAuthorResult, error) {
	return getPostsByAuthorImpl(ctx, db, authorId)
}

var getPostsByAuthorImpl func(context.Context, neogo.Driver, int) ([]*getPostsByAuthorResult, error) = getPostsByAuthorProd

func getPostsByAuthorProd(ctx context.Context, db neogo.Driver, authorId int) ([]*getPostsByAuthorResult, error) {
	var rowsID []int
	var rowsTitle []string
	var rowsContent []string
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $authorId})-[:AUTHORED]->(p:Post)
	RETURN p.id, p.title, p.content
	ORDER BY p.createdAt DESC`).
		RunWithParams(ctx, map[string]any{"authorId": authorId}, "p.id", &rowsID, "p.title", &rowsTitle, "p.content", &rowsContent)
	if err != nil {
		return nil, err
	}
	results := make([]*getPostsByAuthorResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getPostsByAuthorResult{
			ID: rowsID[i],
			Title: rowsTitle[i],
			Content: rowsContent[i],
		}
	}
	return results, nil
}

func ListPosts(ctx context.Context, db neogo.Driver) ([]*listPostsResult, error) {
	return listPostsImpl(ctx, db)
}

var listPostsImpl func(context.Context, neogo.Driver) ([]*listPostsResult, error) = listPostsProd

func listPostsProd(ctx context.Context, db neogo.Driver) ([]*listPostsResult, error) {
	var rowsID []int
	var rowsTitle []string
	var rowsAuthorName []string
	err := db.Exec().
		Cypher(`MATCH (p:Post)
	OPTIONAL MATCH (author:User)-[:AUTHORED]->(p)
	RETURN p.id, p.title, author.name as authorName
	ORDER BY p.createdAt DESC`).
		Run(ctx, "p.id", &rowsID, "p.title", &rowsTitle, "authorName", &rowsAuthorName)
	if err != nil {
		return nil, err
	}
	results := make([]*listPostsResult, len(rowsID))
	for i := range rowsID {
		results[i] = &listPostsResult{
			ID: rowsID[i],
			Title: rowsTitle[i],
			AuthorName: rowsAuthorName[i],
		}
	}
	return results, nil
}

func UpdatePost(ctx context.Context, db neogo.Driver, id int, title string, content string) ([]*updatePostResult, error) {
	return updatePostImpl(ctx, db, id, title, content)
}

var updatePostImpl func(context.Context, neogo.Driver, int, string, string) ([]*updatePostResult, error) = updatePostProd

func updatePostProd(ctx context.Context, db neogo.Driver, id int, title string, content string) ([]*updatePostResult, error) {
	var rowsID []int
	var rowsTitle []string
	var rowsContent []string
	err := db.Exec().
		Cypher(`MATCH (p:Post {id: $id})
	SET p.title = $title, p.content = $content
	RETURN p.id, p.title, p.content`).
		RunWithParams(ctx, map[string]any{"id": id, "title": title, "content": content}, "p.id", &rowsID, "p.title", &rowsTitle, "p.content", &rowsContent)
	if err != nil {
		return nil, err
	}
	results := make([]*updatePostResult, len(rowsID))
	for i := range rowsID {
		results[i] = &updatePostResult{
			ID: rowsID[i],
			Title: rowsTitle[i],
			Content: rowsContent[i],
		}
	}
	return results, nil
}

func DeletePost(ctx context.Context, db neogo.Driver, id int) ([]int, error) {
	return deletePostImpl(ctx, db, id)
}

var deletePostImpl func(context.Context, neogo.Driver, int) ([]int, error) = deletePostProd

func deletePostProd(ctx context.Context, db neogo.Driver, id int) ([]int, error) {
	var rowsDeleted []int
	err := db.Exec().
		Cypher(`MATCH (p:Post {id: $id})
	DETACH DELETE p
	RETURN count(p) as deleted`).
		RunWithParams(ctx, map[string]any{"id": id}, "deleted", &rowsDeleted)
	if err != nil {
		return nil, err
	}
	return rowsDeleted, nil
}

func CountPosts(ctx context.Context, db neogo.Driver) ([]int, error) {
	return countPostsImpl(ctx, db)
}

var countPostsImpl func(context.Context, neogo.Driver) ([]int, error) = countPostsProd

func countPostsProd(ctx context.Context, db neogo.Driver) ([]int, error) {
	var rowsCount []int
	err := db.Exec().
		Cypher(`MATCH (p:Post)
	RETURN count(p) as count`).
		Run(ctx, "count", &rowsCount)
	if err != nil {
		return nil, err
	}
	return rowsCount, nil
}

func CountRelationships(ctx context.Context, db neogo.Driver) ([]int, error) {
	return countRelationshipsImpl(ctx, db)
}

var countRelationshipsImpl func(context.Context, neogo.Driver) ([]int, error) = countRelationshipsProd

func countRelationshipsProd(ctx context.Context, db neogo.Driver) ([]int, error) {
	var rowsCount []int
	err := db.Exec().
		Cypher(`MATCH ()-[r:AUTHORED]->()
	RETURN count(r) as count`).
		Run(ctx, "count", &rowsCount)
	if err != nil {
		return nil, err
	}
	return rowsCount, nil
}

func CreateUser(ctx context.Context, db neogo.Driver, id int, name string, email string, createdAt int) ([]*createUserResult, error) {
	return createUserImpl(ctx, db, id, name, email, createdAt)
}

var createUserImpl func(context.Context, neogo.Driver, int, string, string, int) ([]*createUserResult, error) = createUserProd

func createUserProd(ctx context.Context, db neogo.Driver, id int, name string, email string, createdAt int) ([]*createUserResult, error) {
	var rowsID []int
	var rowsName []string
	var rowsEmail []string
	err := db.Exec().
		Cypher(`CREATE (u:User {id: $id, name: $name, email: $email, createdAt: $createdAt})
	RETURN u.id, u.name, u.email`).
		RunWithParams(ctx, map[string]any{"id": id, "name": name, "email": email, "createdAt": createdAt}, "u.id", &rowsID, "u.name", &rowsName, "u.email", &rowsEmail)
	if err != nil {
		return nil, err
	}
	results := make([]*createUserResult, len(rowsID))
	for i := range rowsID {
		results[i] = &createUserResult{
			ID: rowsID[i],
			Name: rowsName[i],
			Email: rowsEmail[i],
		}
	}
	return results, nil
}

func GetUserById(ctx context.Context, db neogo.Driver, id int) ([]*getUserByIdResult, error) {
	return getUserByIdImpl(ctx, db, id)
}

var getUserByIdImpl func(context.Context, neogo.Driver, int) ([]*getUserByIdResult, error) = getUserByIdProd

func getUserByIdProd(ctx context.Context, db neogo.Driver, id int) ([]*getUserByIdResult, error) {
	var rowsID []int
	var rowsName []string
	var rowsEmail []string
	var rowsCreatedAt []int
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $id})
	RETURN u.id, u.name, u.email, u.createdAt`).
		RunWithParams(ctx, map[string]any{"id": id}, "u.id", &rowsID, "u.name", &rowsName, "u.email", &rowsEmail, "u.createdAt", &rowsCreatedAt)
	if err != nil {
		return nil, err
	}
	results := make([]*getUserByIdResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getUserByIdResult{
			ID: rowsID[i],
			Name: rowsName[i],
			Email: rowsEmail[i],
			CreatedAt: rowsCreatedAt[i],
		}
	}
	return results, nil
}

func GetUserByEmail(ctx context.Context, db neogo.Driver, email string) ([]*getUserByEmailResult, error) {
	return getUserByEmailImpl(ctx, db, email)
}

var getUserByEmailImpl func(context.Context, neogo.Driver, string) ([]*getUserByEmailResult, error) = getUserByEmailProd

func getUserByEmailProd(ctx context.Context, db neogo.Driver, email string) ([]*getUserByEmailResult, error) {
	var rowsID []int
	var rowsName []string
	var rowsEmail []string
	err := db.Exec().
		Cypher(`MATCH (u:User {email: $email})
	RETURN u.id, u.name, u.email`).
		RunWithParams(ctx, map[string]any{"email": email}, "u.id", &rowsID, "u.name", &rowsName, "u.email", &rowsEmail)
	if err != nil {
		return nil, err
	}
	results := make([]*getUserByEmailResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getUserByEmailResult{
			ID: rowsID[i],
			Name: rowsName[i],
			Email: rowsEmail[i],
		}
	}
	return results, nil
}

func ListUsers(ctx context.Context, db neogo.Driver) ([]*listUsersResult, error) {
	return listUsersImpl(ctx, db)
}

var listUsersImpl func(context.Context, neogo.Driver) ([]*listUsersResult, error) = listUsersProd

func listUsersProd(ctx context.Context, db neogo.Driver) ([]*listUsersResult, error) {
	var rowsID []int
	var rowsName []string
	var rowsEmail []string
	err := db.Exec().
		Cypher(`MATCH (u:User)
	RETURN u.id, u.name, u.email
	ORDER BY u.createdAt DESC`).
		Run(ctx, "u.id", &rowsID, "u.name", &rowsName, "u.email", &rowsEmail)
	if err != nil {
		return nil, err
	}
	results := make([]*listUsersResult, len(rowsID))
	for i := range rowsID {
		results[i] = &listUsersResult{
			ID: rowsID[i],
			Name: rowsName[i],
			Email: rowsEmail[i],
		}
	}
	return results, nil
}

func UpdateUser(ctx context.Context, db neogo.Driver, id int, name string, email string) ([]*updateUserResult, error) {
	return updateUserImpl(ctx, db, id, name, email)
}

var updateUserImpl func(context.Context, neogo.Driver, int, string, string) ([]*updateUserResult, error) = updateUserProd

func updateUserProd(ctx context.Context, db neogo.Driver, id int, name string, email string) ([]*updateUserResult, error) {
	var rowsID []int
	var rowsName []string
	var rowsEmail []string
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $id})
	SET u.name = $name, u.email = $email
	RETURN u.id, u.name, u.email`).
		RunWithParams(ctx, map[string]any{"id": id, "name": name, "email": email}, "u.id", &rowsID, "u.name", &rowsName, "u.email", &rowsEmail)
	if err != nil {
		return nil, err
	}
	results := make([]*updateUserResult, len(rowsID))
	for i := range rowsID {
		results[i] = &updateUserResult{
			ID: rowsID[i],
			Name: rowsName[i],
			Email: rowsEmail[i],
		}
	}
	return results, nil
}

func DeleteUser(ctx context.Context, db neogo.Driver, id int) ([]int, error) {
	return deleteUserImpl(ctx, db, id)
}

var deleteUserImpl func(context.Context, neogo.Driver, int) ([]int, error) = deleteUserProd

func deleteUserProd(ctx context.Context, db neogo.Driver, id int) ([]int, error) {
	var rowsDeleted []int
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $id})
	DETACH DELETE u
	RETURN count(u) as deleted`).
		RunWithParams(ctx, map[string]any{"id": id}, "deleted", &rowsDeleted)
	if err != nil {
		return nil, err
	}
	return rowsDeleted, nil
}

func CountUsers(ctx context.Context, db neogo.Driver) ([]int, error) {
	return countUsersImpl(ctx, db)
}

var countUsersImpl func(context.Context, neogo.Driver) ([]int, error) = countUsersProd

func countUsersProd(ctx context.Context, db neogo.Driver) ([]int, error) {
	var rowsCount []int
	err := db.Exec().
		Cypher(`MATCH (u:User)
	RETURN count(u) as count`).
		Run(ctx, "count", &rowsCount)
	if err != nil {
		return nil, err
	}
	return rowsCount, nil
}
