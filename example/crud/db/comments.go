// Code generated by scaf. DO NOT EDIT.

package db

import (
	"context"
	"github.com/rlch/neogo"
)

type createCommentResult struct {
	ID   int
	Text string
}

type getCommentByIdResult struct {
	ID         int
	Text       string
	AuthorName string
	PostTitle  string
}

type getCommentsByPostResult struct {
	ID         int
	Text       string
	AuthorName string
}

type getCommentsByUserResult struct {
	ID        int
	Text      string
	PostTitle string
}

type updateCommentResult struct {
	ID   int
	Text string
}

type createReplyResult struct {
	ID   int
	Text string
}

type getRepliesResult struct {
	ID         int
	Text       string
	AuthorName string
}

func CreateComment(ctx context.Context, db neogo.Driver, authorId int, postId int, id int, text string, createdAt int) ([]*createCommentResult, error) {
	return createCommentImpl(ctx, db, authorId, postId, id, text, createdAt)
}

var createCommentImpl func(context.Context, neogo.Driver, int, int, int, string, int) ([]*createCommentResult, error) = createCommentProd

func createCommentProd(ctx context.Context, db neogo.Driver, authorId int, postId int, id int, text string, createdAt int) ([]*createCommentResult, error) {
	var rowsID []int
	var rowsText []string
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $authorId}), (p:Post {id: $postId})
	CREATE (c:Comment {id: $id, text: $text, createdAt: $createdAt})
	CREATE (u)-[:WROTE]->(c)
	CREATE (p)-[:HAS]->(c)
	RETURN c.id, c.text`).
		RunWithParams(ctx, map[string]any{"authorId": authorId, "postId": postId, "id": id, "text": text, "createdAt": createdAt}, "c.id", &rowsID, "c.text", &rowsText)
	if err != nil {
		return nil, err
	}
	results := make([]*createCommentResult, len(rowsID))
	for i := range rowsID {
		results[i] = &createCommentResult{
			ID:   rowsID[i],
			Text: rowsText[i],
		}
	}
	return results, nil
}

func GetCommentById(ctx context.Context, db neogo.Driver, id int) ([]*getCommentByIdResult, error) {
	return getCommentByIdImpl(ctx, db, id)
}

var getCommentByIdImpl func(context.Context, neogo.Driver, int) ([]*getCommentByIdResult, error) = getCommentByIdProd

func getCommentByIdProd(ctx context.Context, db neogo.Driver, id int) ([]*getCommentByIdResult, error) {
	var rowsID []int
	var rowsText []string
	var rowsAuthorName []string
	var rowsPostTitle []string
	err := db.Exec().
		Cypher(`MATCH (c:Comment {id: $id})
	OPTIONAL MATCH (author:User)-[:WROTE]->(c)
	OPTIONAL MATCH (post:Post)-[:HAS]->(c)
	RETURN c.id, c.text, author.name as authorName, post.title as postTitle`).
		RunWithParams(ctx, map[string]any{"id": id}, "c.id", &rowsID, "c.text", &rowsText, "authorName", &rowsAuthorName, "postTitle", &rowsPostTitle)
	if err != nil {
		return nil, err
	}
	results := make([]*getCommentByIdResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getCommentByIdResult{
			ID:         rowsID[i],
			Text:       rowsText[i],
			AuthorName: rowsAuthorName[i],
			PostTitle:  rowsPostTitle[i],
		}
	}
	return results, nil
}

func GetCommentsByPost(ctx context.Context, db neogo.Driver, postId int) ([]*getCommentsByPostResult, error) {
	return getCommentsByPostImpl(ctx, db, postId)
}

var getCommentsByPostImpl func(context.Context, neogo.Driver, int) ([]*getCommentsByPostResult, error) = getCommentsByPostProd

func getCommentsByPostProd(ctx context.Context, db neogo.Driver, postId int) ([]*getCommentsByPostResult, error) {
	var rowsID []int
	var rowsText []string
	var rowsAuthorName []string
	err := db.Exec().
		Cypher(`MATCH (p:Post {id: $postId})-[:HAS]->(c:Comment)
	OPTIONAL MATCH (author:User)-[:WROTE]->(c)
	RETURN c.id, c.text, author.name as authorName
	ORDER BY c.createdAt ASC`).
		RunWithParams(ctx, map[string]any{"postId": postId}, "c.id", &rowsID, "c.text", &rowsText, "authorName", &rowsAuthorName)
	if err != nil {
		return nil, err
	}
	results := make([]*getCommentsByPostResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getCommentsByPostResult{
			ID:         rowsID[i],
			Text:       rowsText[i],
			AuthorName: rowsAuthorName[i],
		}
	}
	return results, nil
}

func GetCommentsByUser(ctx context.Context, db neogo.Driver, userId int) ([]*getCommentsByUserResult, error) {
	return getCommentsByUserImpl(ctx, db, userId)
}

var getCommentsByUserImpl func(context.Context, neogo.Driver, int) ([]*getCommentsByUserResult, error) = getCommentsByUserProd

func getCommentsByUserProd(ctx context.Context, db neogo.Driver, userId int) ([]*getCommentsByUserResult, error) {
	var rowsID []int
	var rowsText []string
	var rowsPostTitle []string
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $userId})-[:WROTE]->(c:Comment)
	OPTIONAL MATCH (p:Post)-[:HAS]->(c)
	RETURN c.id, c.text, p.title as postTitle
	ORDER BY c.createdAt DESC`).
		RunWithParams(ctx, map[string]any{"userId": userId}, "c.id", &rowsID, "c.text", &rowsText, "postTitle", &rowsPostTitle)
	if err != nil {
		return nil, err
	}
	results := make([]*getCommentsByUserResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getCommentsByUserResult{
			ID:        rowsID[i],
			Text:      rowsText[i],
			PostTitle: rowsPostTitle[i],
		}
	}
	return results, nil
}

func UpdateComment(ctx context.Context, db neogo.Driver, id int, text string) ([]*updateCommentResult, error) {
	return updateCommentImpl(ctx, db, id, text)
}

var updateCommentImpl func(context.Context, neogo.Driver, int, string) ([]*updateCommentResult, error) = updateCommentProd

func updateCommentProd(ctx context.Context, db neogo.Driver, id int, text string) ([]*updateCommentResult, error) {
	var rowsID []int
	var rowsText []string
	err := db.Exec().
		Cypher(`MATCH (c:Comment {id: $id})
	SET c.text = $text
	RETURN c.id, c.text`).
		RunWithParams(ctx, map[string]any{"id": id, "text": text}, "c.id", &rowsID, "c.text", &rowsText)
	if err != nil {
		return nil, err
	}
	results := make([]*updateCommentResult, len(rowsID))
	for i := range rowsID {
		results[i] = &updateCommentResult{
			ID:   rowsID[i],
			Text: rowsText[i],
		}
	}
	return results, nil
}

func DeleteComment(ctx context.Context, db neogo.Driver, id int) ([]int, error) {
	return deleteCommentImpl(ctx, db, id)
}

var deleteCommentImpl func(context.Context, neogo.Driver, int) ([]int, error) = deleteCommentProd

func deleteCommentProd(ctx context.Context, db neogo.Driver, id int) ([]int, error) {
	var rowsDeleted []int
	err := db.Exec().
		Cypher(`MATCH (c:Comment {id: $id})
	DETACH DELETE c
	RETURN count(c) as deleted`).
		RunWithParams(ctx, map[string]any{"id": id}, "deleted", &rowsDeleted)
	if err != nil {
		return nil, err
	}
	return rowsDeleted, nil
}

func CountCommentsByPost(ctx context.Context, db neogo.Driver, postId int) ([]int, error) {
	return countCommentsByPostImpl(ctx, db, postId)
}

var countCommentsByPostImpl func(context.Context, neogo.Driver, int) ([]int, error) = countCommentsByPostProd

func countCommentsByPostProd(ctx context.Context, db neogo.Driver, postId int) ([]int, error) {
	var rowsCount []int
	err := db.Exec().
		Cypher(`MATCH (p:Post {id: $postId})-[:HAS]->(c:Comment)
	RETURN count(c) as count`).
		RunWithParams(ctx, map[string]any{"postId": postId}, "count", &rowsCount)
	if err != nil {
		return nil, err
	}
	return rowsCount, nil
}

func CreateReply(ctx context.Context, db neogo.Driver, authorId int, parentId int, id int, text string, createdAt int) ([]*createReplyResult, error) {
	return createReplyImpl(ctx, db, authorId, parentId, id, text, createdAt)
}

var createReplyImpl func(context.Context, neogo.Driver, int, int, int, string, int) ([]*createReplyResult, error) = createReplyProd

func createReplyProd(ctx context.Context, db neogo.Driver, authorId int, parentId int, id int, text string, createdAt int) ([]*createReplyResult, error) {
	var rowsID []int
	var rowsText []string
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $authorId}), (parent:Comment {id: $parentId})
	CREATE (c:Comment {id: $id, text: $text, createdAt: $createdAt})
	CREATE (u)-[:WROTE]->(c)
	CREATE (c)-[:REPLIES]->(parent)
	RETURN c.id, c.text`).
		RunWithParams(ctx, map[string]any{"authorId": authorId, "parentId": parentId, "id": id, "text": text, "createdAt": createdAt}, "c.id", &rowsID, "c.text", &rowsText)
	if err != nil {
		return nil, err
	}
	results := make([]*createReplyResult, len(rowsID))
	for i := range rowsID {
		results[i] = &createReplyResult{
			ID:   rowsID[i],
			Text: rowsText[i],
		}
	}
	return results, nil
}

func GetReplies(ctx context.Context, db neogo.Driver, commentId int) ([]*getRepliesResult, error) {
	return getRepliesImpl(ctx, db, commentId)
}

var getRepliesImpl func(context.Context, neogo.Driver, int) ([]*getRepliesResult, error) = getRepliesProd

func getRepliesProd(ctx context.Context, db neogo.Driver, commentId int) ([]*getRepliesResult, error) {
	var rowsID []int
	var rowsText []string
	var rowsAuthorName []string
	err := db.Exec().
		Cypher(`MATCH (reply:Comment)-[:REPLIES]->(c:Comment {id: $commentId})
	OPTIONAL MATCH (author:User)-[:WROTE]->(reply)
	RETURN reply.id, reply.text, author.name as authorName
	ORDER BY reply.createdAt ASC`).
		RunWithParams(ctx, map[string]any{"commentId": commentId}, "reply.id", &rowsID, "reply.text", &rowsText, "authorName", &rowsAuthorName)
	if err != nil {
		return nil, err
	}
	results := make([]*getRepliesResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getRepliesResult{
			ID:         rowsID[i],
			Text:       rowsText[i],
			AuthorName: rowsAuthorName[i],
		}
	}
	return results, nil
}

func CountReplies(ctx context.Context, db neogo.Driver, commentId int) ([]int, error) {
	return countRepliesImpl(ctx, db, commentId)
}

var countRepliesImpl func(context.Context, neogo.Driver, int) ([]int, error) = countRepliesProd

func countRepliesProd(ctx context.Context, db neogo.Driver, commentId int) ([]int, error) {
	var rowsCount []int
	err := db.Exec().
		Cypher(`MATCH (reply:Comment)-[:REPLIES]->(c:Comment {id: $commentId})
	RETURN count(reply) as count`).
		RunWithParams(ctx, map[string]any{"commentId": commentId}, "count", &rowsCount)
	if err != nil {
		return nil, err
	}
	return rowsCount, nil
}
