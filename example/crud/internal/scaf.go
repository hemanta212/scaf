// Code generated by scaf. DO NOT EDIT.

package internal

import (
	"context"

	"github.com/rlch/neogo"
)

type createCommentResult struct {
	ID   int
	Text string
}

type getCommentByIdResult struct {
	ID         int
	Text       string
	AuthorName string
	PostTitle  string
}

type getCommentsByPostResult struct {
	ID         int
	Text       string
	AuthorName string
}

type getCommentsByUserResult struct {
	ID        int
	Text      string
	PostTitle string
}

type updateCommentResult struct {
	ID   int
	Text string
}

type createReplyResult struct {
	ID   int
	Text string
}

type getRepliesResult struct {
	ID         int
	Text       string
	AuthorName string
}

type getFollowersResult struct {
	ID    int
	Name  string
	Email string
}

type getFollowingResult struct {
	ID    int
	Name  string
	Email string
}

type getFeedResult struct {
	ID         int
	Content    string
	CreatedAt  int
	AuthorId   int
	AuthorName string
}

type getMutualFollowersResult struct {
	ID   int
	Name string
}

type createPostResult struct {
	ID         int
	Content    string
	AuthorName any
}

type getPostResult struct {
	ID         int
	Content    string
	CreatedAt  int
	AuthorId   int
	AuthorName string
}

type getUserPostsResult struct {
	ID        int
	Content   string
	CreatedAt int
}

type getPostLikesResult struct {
	LikeCount int
	Likers    []string
}

type createUserResult struct {
	ID    int
	Name  string
	Email string
}

type getUserByIdResult struct {
	ID        int
	Name      string
	Email     string
	CreatedAt int
}

type getUserByEmailResult struct {
	ID    int
	Name  string
	Email string
}

type listUsersResult struct {
	ID    int
	Name  string
	Email string
}

type updateUserResult struct {
	ID    int
	Name  string
	Email string
}

func CreateComment(ctx context.Context, db neogo.Driver, authorId int, postId int, id int, text string, createdAt int) ([]*createCommentResult, error) {
	return createCommentImpl(ctx, db, authorId, postId, id, text, createdAt)
}

var createCommentImpl func(context.Context, neogo.Driver, int, int, int, string, int) ([]*createCommentResult, error) = createCommentProd

func createCommentProd(ctx context.Context, db neogo.Driver, authorId int, postId int, id int, text string, createdAt int) ([]*createCommentResult, error) {
	var rowsID []int
	var rowsText []string
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $authorId}), (p:Post {id: $postId})
	CREATE (c:Comment {id: $id, text: $text, createdAt: $createdAt})
	CREATE (u)-[:WROTE]->(c)
	CREATE (p)-[:HAS]->(c)
	RETURN c.id, c.text`).
		RunWithParams(ctx, map[string]any{"authorId": authorId, "postId": postId, "id": id, "text": text, "createdAt": createdAt}, "c.id", &rowsID, "c.text", &rowsText)
	if err != nil {
		return nil, err
	}
	results := make([]*createCommentResult, len(rowsID))
	for i := range rowsID {
		results[i] = &createCommentResult{
			ID:   rowsID[i],
			Text: rowsText[i],
		}
	}
	return results, nil
}

func GetCommentById(ctx context.Context, db neogo.Driver, id int) ([]*getCommentByIdResult, error) {
	return getCommentByIdImpl(ctx, db, id)
}

var getCommentByIdImpl func(context.Context, neogo.Driver, int) ([]*getCommentByIdResult, error) = getCommentByIdProd

func getCommentByIdProd(ctx context.Context, db neogo.Driver, id int) ([]*getCommentByIdResult, error) {
	var rowsID []int
	var rowsText []string
	var rowsAuthorName []string
	var rowsPostTitle []string
	err := db.Exec().
		Cypher(`MATCH (c:Comment {id: $id})
	OPTIONAL MATCH (author:User)-[:WROTE]->(c)
	OPTIONAL MATCH (post:Post)-[:HAS]->(c)
	RETURN c.id, c.text, author.name as authorName, post.title as postTitle`).
		RunWithParams(ctx, map[string]any{"id": id}, "c.id", &rowsID, "c.text", &rowsText, "authorName", &rowsAuthorName, "postTitle", &rowsPostTitle)
	if err != nil {
		return nil, err
	}
	results := make([]*getCommentByIdResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getCommentByIdResult{
			ID:         rowsID[i],
			Text:       rowsText[i],
			AuthorName: rowsAuthorName[i],
			PostTitle:  rowsPostTitle[i],
		}
	}
	return results, nil
}

func GetCommentsByPost(ctx context.Context, db neogo.Driver, postId int) ([]*getCommentsByPostResult, error) {
	return getCommentsByPostImpl(ctx, db, postId)
}

var getCommentsByPostImpl func(context.Context, neogo.Driver, int) ([]*getCommentsByPostResult, error) = getCommentsByPostProd

func getCommentsByPostProd(ctx context.Context, db neogo.Driver, postId int) ([]*getCommentsByPostResult, error) {
	var rowsID []int
	var rowsText []string
	var rowsAuthorName []string
	err := db.Exec().
		Cypher(`MATCH (p:Post {id: $postId})-[:HAS]->(c:Comment)
	OPTIONAL MATCH (author:User)-[:WROTE]->(c)
	RETURN c.id, c.text, author.name as authorName
	ORDER BY c.createdAt ASC`).
		RunWithParams(ctx, map[string]any{"postId": postId}, "c.id", &rowsID, "c.text", &rowsText, "authorName", &rowsAuthorName)
	if err != nil {
		return nil, err
	}
	results := make([]*getCommentsByPostResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getCommentsByPostResult{
			ID:         rowsID[i],
			Text:       rowsText[i],
			AuthorName: rowsAuthorName[i],
		}
	}
	return results, nil
}

func GetCommentsByUser(ctx context.Context, db neogo.Driver, userId int) ([]*getCommentsByUserResult, error) {
	return getCommentsByUserImpl(ctx, db, userId)
}

var getCommentsByUserImpl func(context.Context, neogo.Driver, int) ([]*getCommentsByUserResult, error) = getCommentsByUserProd

func getCommentsByUserProd(ctx context.Context, db neogo.Driver, userId int) ([]*getCommentsByUserResult, error) {
	var rowsID []int
	var rowsText []string
	var rowsPostTitle []string
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $userId})-[:WROTE]->(c:Comment)
	OPTIONAL MATCH (p:Post)-[:HAS]->(c)
	RETURN c.id, c.text, p.title as postTitle
	ORDER BY c.createdAt DESC`).
		RunWithParams(ctx, map[string]any{"userId": userId}, "c.id", &rowsID, "c.text", &rowsText, "postTitle", &rowsPostTitle)
	if err != nil {
		return nil, err
	}
	results := make([]*getCommentsByUserResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getCommentsByUserResult{
			ID:        rowsID[i],
			Text:      rowsText[i],
			PostTitle: rowsPostTitle[i],
		}
	}
	return results, nil
}

func UpdateComment(ctx context.Context, db neogo.Driver, id int, text string) ([]*updateCommentResult, error) {
	return updateCommentImpl(ctx, db, id, text)
}

var updateCommentImpl func(context.Context, neogo.Driver, int, string) ([]*updateCommentResult, error) = updateCommentProd

func updateCommentProd(ctx context.Context, db neogo.Driver, id int, text string) ([]*updateCommentResult, error) {
	var rowsID []int
	var rowsText []string
	err := db.Exec().
		Cypher(`MATCH (c:Comment {id: $id})
	SET c.text = $text
	RETURN c.id, c.text`).
		RunWithParams(ctx, map[string]any{"id": id, "text": text}, "c.id", &rowsID, "c.text", &rowsText)
	if err != nil {
		return nil, err
	}
	results := make([]*updateCommentResult, len(rowsID))
	for i := range rowsID {
		results[i] = &updateCommentResult{
			ID:   rowsID[i],
			Text: rowsText[i],
		}
	}
	return results, nil
}

func DeleteComment(ctx context.Context, db neogo.Driver, id int) ([]int, error) {
	return deleteCommentImpl(ctx, db, id)
}

var deleteCommentImpl func(context.Context, neogo.Driver, int) ([]int, error) = deleteCommentProd

func deleteCommentProd(ctx context.Context, db neogo.Driver, id int) ([]int, error) {
	var rowsDeleted []int
	err := db.Exec().
		Cypher(`MATCH (c:Comment {id: $id})
	DETACH DELETE c
	RETURN count(c) as deleted`).
		RunWithParams(ctx, map[string]any{"id": id}, "deleted", &rowsDeleted)
	if err != nil {
		return nil, err
	}
	return rowsDeleted, nil
}

func CountCommentsByPost(ctx context.Context, db neogo.Driver, postId int) ([]int, error) {
	return countCommentsByPostImpl(ctx, db, postId)
}

var countCommentsByPostImpl func(context.Context, neogo.Driver, int) ([]int, error) = countCommentsByPostProd

func countCommentsByPostProd(ctx context.Context, db neogo.Driver, postId int) ([]int, error) {
	var rowsCount []int
	err := db.Exec().
		Cypher(`MATCH (p:Post {id: $postId})-[:HAS]->(c:Comment)
	RETURN count(c) as count`).
		RunWithParams(ctx, map[string]any{"postId": postId}, "count", &rowsCount)
	if err != nil {
		return nil, err
	}
	return rowsCount, nil
}

func CreateReply(ctx context.Context, db neogo.Driver, authorId int, parentId int, id int, text string, createdAt int) ([]*createReplyResult, error) {
	return createReplyImpl(ctx, db, authorId, parentId, id, text, createdAt)
}

var createReplyImpl func(context.Context, neogo.Driver, int, int, int, string, int) ([]*createReplyResult, error) = createReplyProd

func createReplyProd(ctx context.Context, db neogo.Driver, authorId int, parentId int, id int, text string, createdAt int) ([]*createReplyResult, error) {
	var rowsID []int
	var rowsText []string
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $authorId}), (parent:Comment {id: $parentId})
	CREATE (c:Comment {id: $id, text: $text, createdAt: $createdAt})
	CREATE (u)-[:WROTE]->(c)
	CREATE (c)-[:REPLIES]->(parent)
	RETURN c.id, c.text`).
		RunWithParams(ctx, map[string]any{"authorId": authorId, "parentId": parentId, "id": id, "text": text, "createdAt": createdAt}, "c.id", &rowsID, "c.text", &rowsText)
	if err != nil {
		return nil, err
	}
	results := make([]*createReplyResult, len(rowsID))
	for i := range rowsID {
		results[i] = &createReplyResult{
			ID:   rowsID[i],
			Text: rowsText[i],
		}
	}
	return results, nil
}

func GetReplies(ctx context.Context, db neogo.Driver, commentId int) ([]*getRepliesResult, error) {
	return getRepliesImpl(ctx, db, commentId)
}

var getRepliesImpl func(context.Context, neogo.Driver, int) ([]*getRepliesResult, error) = getRepliesProd

func getRepliesProd(ctx context.Context, db neogo.Driver, commentId int) ([]*getRepliesResult, error) {
	var rowsID []int
	var rowsText []string
	var rowsAuthorName []string
	err := db.Exec().
		Cypher(`MATCH (reply:Comment)-[:REPLIES]->(c:Comment {id: $commentId})
	OPTIONAL MATCH (author:User)-[:WROTE]->(reply)
	RETURN reply.id, reply.text, author.name as authorName
	ORDER BY reply.createdAt ASC`).
		RunWithParams(ctx, map[string]any{"commentId": commentId}, "reply.id", &rowsID, "reply.text", &rowsText, "authorName", &rowsAuthorName)
	if err != nil {
		return nil, err
	}
	results := make([]*getRepliesResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getRepliesResult{
			ID:         rowsID[i],
			Text:       rowsText[i],
			AuthorName: rowsAuthorName[i],
		}
	}
	return results, nil
}

func CountReplies(ctx context.Context, db neogo.Driver, commentId int) ([]int, error) {
	return countRepliesImpl(ctx, db, commentId)
}

var countRepliesImpl func(context.Context, neogo.Driver, int) ([]int, error) = countRepliesProd

func countRepliesProd(ctx context.Context, db neogo.Driver, commentId int) ([]int, error) {
	var rowsCount []int
	err := db.Exec().
		Cypher(`MATCH (reply:Comment)-[:REPLIES]->(c:Comment {id: $commentId})
	RETURN count(reply) as count`).
		RunWithParams(ctx, map[string]any{"commentId": commentId}, "count", &rowsCount)
	if err != nil {
		return nil, err
	}
	return rowsCount, nil
}

func CreateUsers(ctx context.Context, db neogo.Driver) error {
	return createUsersImpl(ctx, db)
}

var createUsersImpl func(context.Context, neogo.Driver) error = createUsersProd

func createUsersProd(ctx context.Context, db neogo.Driver) error {
	err := db.Exec().
		Cypher(`CREATE (alice:User {id: 1, name: "Alice", email: "alice@example.com", createdAt: 1700000000})
	CREATE (bob:User {id: 2, name: "Bob", email: "bob@example.com", createdAt: 1700000001})
	CREATE (charlie:User {id: 3, name: "Charlie", email: "charlie@example.com", createdAt: 1700000002})`).
		Run(ctx)
	if err != nil {
		return err
	}
	return nil
}

func CreatePosts(ctx context.Context, db neogo.Driver) error {
	return createPostsImpl(ctx, db)
}

var createPostsImpl func(context.Context, neogo.Driver) error = createPostsProd

func createPostsProd(ctx context.Context, db neogo.Driver) error {
	err := db.Exec().
		Cypher(`MATCH (alice:User {id: 1}), (bob:User {id: 2})
	CREATE (p1:Post {id: 1, title: "Hello World", content: "Hello World", createdAt: 1700000100})
	CREATE (p2:Post {id: 2, title: "Learning Neo4j", content: "Learning Neo4j", createdAt: 1700000200})
	CREATE (p3:Post {id: 3, title: "Bob's Post", content: "Bob's Post", createdAt: 1700000300})
	CREATE (alice)-[:AUTHORED]->(p1)
	CREATE (alice)-[:AUTHORED]->(p2)
	CREATE (bob)-[:AUTHORED]->(p3)`).
		Run(ctx)
	if err != nil {
		return err
	}
	return nil
}

func CreateComments(ctx context.Context, db neogo.Driver) error {
	return createCommentsImpl(ctx, db)
}

var createCommentsImpl func(context.Context, neogo.Driver) error = createCommentsProd

func createCommentsProd(ctx context.Context, db neogo.Driver) error {
	err := db.Exec().
		Cypher(`MATCH (alice:User {id: 1}), (bob:User {id: 2}), (p1:Post {id: 1})
	CREATE (c1:Comment {id: 1, text: "Great post!", createdAt: 1700000150})
	CREATE (c2:Comment {id: 2, text: "Thanks for sharing", createdAt: 1700000160})
	CREATE (c3:Comment {id: 3, text: "I agree!", createdAt: 1700000170})
	CREATE (bob)-[:WROTE]->(c1)
	CREATE (alice)-[:WROTE]->(c2)
	CREATE (bob)-[:WROTE]->(c3)
	CREATE (p1)-[:HAS]->(c1)
	CREATE (p1)-[:HAS]->(c2)
	CREATE (p1)-[:HAS]->(c3)`).
		Run(ctx)
	if err != nil {
		return err
	}
	return nil
}

func CreateUser(ctx context.Context, db neogo.Driver, id int, name string, email string) error {
	return createUserImpl(ctx, db, id, name, email)
}

var createUserImpl func(context.Context, neogo.Driver, int, string, string) error = createUserProd

func createUserProd(ctx context.Context, db neogo.Driver, id int, name string, email string) error {
	err := db.Exec().
		Cypher(`CREATE (:User {id: $id, name: $name, email: $email, createdAt: timestamp()})`).
		RunWithParams(ctx, map[string]any{"id": id, "name": name, "email": email})
	if err != nil {
		return err
	}
	return nil
}

func CreatePost(ctx context.Context, db neogo.Driver, authorId int, id int, content string) error {
	return createPostImpl(ctx, db, authorId, id, content)
}

var createPostImpl func(context.Context, neogo.Driver, int, int, string) error = createPostProd

func createPostProd(ctx context.Context, db neogo.Driver, authorId int, id int, content string) error {
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $authorId})
	CREATE (p:Post {id: $id, content: $content, createdAt: timestamp()})
	CREATE (u)-[:AUTHORED]->(p)`).
		RunWithParams(ctx, map[string]any{"authorId": authorId, "id": id, "content": content})
	if err != nil {
		return err
	}
	return nil
}

func CreateFollow(ctx context.Context, db neogo.Driver, followerId int, followeeId int) error {
	return createFollowImpl(ctx, db, followerId, followeeId)
}

var createFollowImpl func(context.Context, neogo.Driver, int, int) error = createFollowProd

func createFollowProd(ctx context.Context, db neogo.Driver, followerId int, followeeId int) error {
	err := db.Exec().
		Cypher(`MATCH (a:User {id: $followerId}), (b:User {id: $followeeId})
	CREATE (a)-[:FOLLOWS {createdAt: timestamp()}]->(b)`).
		RunWithParams(ctx, map[string]any{"followerId": followerId, "followeeId": followeeId})
	if err != nil {
		return err
	}
	return nil
}

func CreateLike(ctx context.Context, db neogo.Driver, userId int, postId int) error {
	return createLikeImpl(ctx, db, userId, postId)
}

var createLikeImpl func(context.Context, neogo.Driver, int, int) error = createLikeProd

func createLikeProd(ctx context.Context, db neogo.Driver, userId int, postId int) error {
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $userId}), (p:Post {id: $postId})
	CREATE (u)-[:LIKED {createdAt: timestamp()}]->(p)`).
		RunWithParams(ctx, map[string]any{"userId": userId, "postId": postId})
	if err != nil {
		return err
	}
	return nil
}

func CreateSocialGraph(ctx context.Context, db neogo.Driver) error {
	return createSocialGraphImpl(ctx, db)
}

var createSocialGraphImpl func(context.Context, neogo.Driver) error = createSocialGraphProd

func createSocialGraphProd(ctx context.Context, db neogo.Driver) error {
	err := db.Exec().
		Cypher(`MATCH (alice:User {id: 1}), (bob:User {id: 2}), (charlie:User {id: 3})
	CREATE (alice)-[:FOLLOWS]->(bob)
	CREATE (alice)-[:FOLLOWS]->(charlie)
	CREATE (bob)-[:FOLLOWS]->(alice)
	CREATE (charlie)-[:FOLLOWS]->(bob)`).
		Run(ctx)
	if err != nil {
		return err
	}
	return nil
}

func CreateEngagement(ctx context.Context, db neogo.Driver) error {
	return createEngagementImpl(ctx, db)
}

var createEngagementImpl func(context.Context, neogo.Driver) error = createEngagementProd

func createEngagementProd(ctx context.Context, db neogo.Driver) error {
	err := db.Exec().
		Cypher(`MATCH (alice:User {id: 1}), (bob:User {id: 2})
	MATCH (p1:Post {id: 1}), (p2:Post {id: 2})
	CREATE (bob)-[:LIKED]->(p1)
	CREATE (alice)-[:LIKED]->(p2)`).
		Run(ctx)
	if err != nil {
		return err
	}
	return nil
}

func Follow(ctx context.Context, db neogo.Driver, followerId int, followeeId int) ([]int, error) {
	return followImpl(ctx, db, followerId, followeeId)
}

var followImpl func(context.Context, neogo.Driver, int, int) ([]int, error) = followProd

func followProd(ctx context.Context, db neogo.Driver, followerId int, followeeId int) ([]int, error) {
	var rowsFollowed []int
	err := db.Exec().
		Cypher(`MATCH (follower:User {id: $followerId}), (followee:User {id: $followeeId})
	MERGE (follower)-[f:FOLLOWS]->(followee)
	ON CREATE SET f.createdAt = timestamp()
	RETURN count(f) as followed`).
		RunWithParams(ctx, map[string]any{"followerId": followerId, "followeeId": followeeId}, "followed", &rowsFollowed)
	if err != nil {
		return nil, err
	}
	return rowsFollowed, nil
}

func Unfollow(ctx context.Context, db neogo.Driver, followerId int, followeeId int) ([]int, error) {
	return unfollowImpl(ctx, db, followerId, followeeId)
}

var unfollowImpl func(context.Context, neogo.Driver, int, int) ([]int, error) = unfollowProd

func unfollowProd(ctx context.Context, db neogo.Driver, followerId int, followeeId int) ([]int, error) {
	var rowsUnfollowed []int
	err := db.Exec().
		Cypher(`MATCH (follower:User {id: $followerId})-[f:FOLLOWS]->(followee:User {id: $followeeId})
	DELETE f
	RETURN count(f) as unfollowed`).
		RunWithParams(ctx, map[string]any{"followerId": followerId, "followeeId": followeeId}, "unfollowed", &rowsUnfollowed)
	if err != nil {
		return nil, err
	}
	return rowsUnfollowed, nil
}

func GetFollowers(ctx context.Context, db neogo.Driver, userId int) ([]*getFollowersResult, error) {
	return getFollowersImpl(ctx, db, userId)
}

var getFollowersImpl func(context.Context, neogo.Driver, int) ([]*getFollowersResult, error) = getFollowersProd

func getFollowersProd(ctx context.Context, db neogo.Driver, userId int) ([]*getFollowersResult, error) {
	var rowsID []int
	var rowsName []string
	var rowsEmail []string
	err := db.Exec().
		Cypher(`MATCH (follower:User)-[:FOLLOWS]->(u:User {id: $userId})
	RETURN follower.id, follower.name, follower.email`).
		RunWithParams(ctx, map[string]any{"userId": userId}, "follower.id", &rowsID, "follower.name", &rowsName, "follower.email", &rowsEmail)
	if err != nil {
		return nil, err
	}
	results := make([]*getFollowersResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getFollowersResult{
			ID:    rowsID[i],
			Name:  rowsName[i],
			Email: rowsEmail[i],
		}
	}
	return results, nil
}

func GetFollowing(ctx context.Context, db neogo.Driver, userId int) ([]*getFollowingResult, error) {
	return getFollowingImpl(ctx, db, userId)
}

var getFollowingImpl func(context.Context, neogo.Driver, int) ([]*getFollowingResult, error) = getFollowingProd

func getFollowingProd(ctx context.Context, db neogo.Driver, userId int) ([]*getFollowingResult, error) {
	var rowsID []int
	var rowsName []string
	var rowsEmail []string
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $userId})-[:FOLLOWS]->(following:User)
	RETURN following.id, following.name, following.email`).
		RunWithParams(ctx, map[string]any{"userId": userId}, "following.id", &rowsID, "following.name", &rowsName, "following.email", &rowsEmail)
	if err != nil {
		return nil, err
	}
	results := make([]*getFollowingResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getFollowingResult{
			ID:    rowsID[i],
			Name:  rowsName[i],
			Email: rowsEmail[i],
		}
	}
	return results, nil
}

func CountFollowers(ctx context.Context, db neogo.Driver, userId int) ([]int, error) {
	return countFollowersImpl(ctx, db, userId)
}

var countFollowersImpl func(context.Context, neogo.Driver, int) ([]int, error) = countFollowersProd

func countFollowersProd(ctx context.Context, db neogo.Driver, userId int) ([]int, error) {
	var rowsCount []int
	err := db.Exec().
		Cypher(`MATCH (follower:User)-[:FOLLOWS]->(u:User {id: $userId})
	RETURN count(follower) as count`).
		RunWithParams(ctx, map[string]any{"userId": userId}, "count", &rowsCount)
	if err != nil {
		return nil, err
	}
	return rowsCount, nil
}

func CountFollowing(ctx context.Context, db neogo.Driver, userId int) ([]int, error) {
	return countFollowingImpl(ctx, db, userId)
}

var countFollowingImpl func(context.Context, neogo.Driver, int) ([]int, error) = countFollowingProd

func countFollowingProd(ctx context.Context, db neogo.Driver, userId int) ([]int, error) {
	var rowsCount []int
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $userId})-[:FOLLOWS]->(following:User)
	RETURN count(following) as count`).
		RunWithParams(ctx, map[string]any{"userId": userId}, "count", &rowsCount)
	if err != nil {
		return nil, err
	}
	return rowsCount, nil
}

func IsFollowing(ctx context.Context, db neogo.Driver, followerId int, followeeId int) ([]bool, error) {
	return isFollowingImpl(ctx, db, followerId, followeeId)
}

var isFollowingImpl func(context.Context, neogo.Driver, int, int) ([]bool, error) = isFollowingProd

func isFollowingProd(ctx context.Context, db neogo.Driver, followerId int, followeeId int) ([]bool, error) {
	var rowsIsFollowing []bool
	err := db.Exec().
		Cypher(`MATCH (follower:User {id: $followerId})-[:FOLLOWS]->(followee:User {id: $followeeId})
	RETURN count(*) > 0 as isFollowing`).
		RunWithParams(ctx, map[string]any{"followerId": followerId, "followeeId": followeeId}, "isFollowing", &rowsIsFollowing)
	if err != nil {
		return nil, err
	}
	return rowsIsFollowing, nil
}

func GetFeed(ctx context.Context, db neogo.Driver, userId int) ([]*getFeedResult, error) {
	return getFeedImpl(ctx, db, userId)
}

var getFeedImpl func(context.Context, neogo.Driver, int) ([]*getFeedResult, error) = getFeedProd

func getFeedProd(ctx context.Context, db neogo.Driver, userId int) ([]*getFeedResult, error) {
	var rowsID []int
	var rowsContent []string
	var rowsCreatedAt []int
	var rowsAuthorId []int
	var rowsAuthorName []string
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $userId})-[:FOLLOWS]->(following:User)-[:AUTHORED]->(p:Post)
	RETURN p.id, p.content, p.createdAt, following.id as authorId, following.name as authorName
	ORDER BY p.createdAt DESC
	LIMIT toInteger($limit)`).
		RunWithParams(ctx, map[string]any{"userId": userId}, "p.id", &rowsID, "p.content", &rowsContent, "p.createdAt", &rowsCreatedAt, "authorId", &rowsAuthorId, "authorName", &rowsAuthorName)
	if err != nil {
		return nil, err
	}
	results := make([]*getFeedResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getFeedResult{
			ID:         rowsID[i],
			Content:    rowsContent[i],
			CreatedAt:  rowsCreatedAt[i],
			AuthorId:   rowsAuthorId[i],
			AuthorName: rowsAuthorName[i],
		}
	}
	return results, nil
}

func GetMutualFollowers(ctx context.Context, db neogo.Driver, userId1 int, userId2 int) ([]*getMutualFollowersResult, error) {
	return getMutualFollowersImpl(ctx, db, userId1, userId2)
}

var getMutualFollowersImpl func(context.Context, neogo.Driver, int, int) ([]*getMutualFollowersResult, error) = getMutualFollowersProd

func getMutualFollowersProd(ctx context.Context, db neogo.Driver, userId1 int, userId2 int) ([]*getMutualFollowersResult, error) {
	var rowsID []int
	var rowsName []string
	err := db.Exec().
		Cypher(`MATCH (u1:User {id: $userId1})<-[:FOLLOWS]-(mutual:User)-[:FOLLOWS]->(u2:User {id: $userId2})
	RETURN mutual.id, mutual.name`).
		RunWithParams(ctx, map[string]any{"userId1": userId1, "userId2": userId2}, "mutual.id", &rowsID, "mutual.name", &rowsName)
	if err != nil {
		return nil, err
	}
	results := make([]*getMutualFollowersResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getMutualFollowersResult{
			ID:   rowsID[i],
			Name: rowsName[i],
		}
	}
	return results, nil
}

func CreatePost(ctx context.Context, db neogo.Driver, authorId int, id int, content string, createdAt int) ([]*createPostResult, error) {
	return createPostImpl(ctx, db, authorId, id, content, createdAt)
}

var createPostImpl func(context.Context, neogo.Driver, int, int, string, int) ([]*createPostResult, error) = createPostProd

func createPostProd(ctx context.Context, db neogo.Driver, authorId int, id int, content string, createdAt int) ([]*createPostResult, error) {
	var rowsID []int
	var rowsContent []string
	var rowsAuthorName []any
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $authorId})
	CREATE (p:Post {id: $id, content: $content, createdAt: $createdAt})
	CREATE (u)-[:AUTHORED]->(p)
	RETURN p.id, p.content, u.name as authorName`).
		RunWithParams(ctx, map[string]any{"authorId": authorId, "id": id, "content": content, "createdAt": createdAt}, "p.id", &rowsID, "p.content", &rowsContent, "authorName", &rowsAuthorName)
	if err != nil {
		return nil, err
	}
	results := make([]*createPostResult, len(rowsID))
	for i := range rowsID {
		results[i] = &createPostResult{
			ID:         rowsID[i],
			Content:    rowsContent[i],
			AuthorName: rowsAuthorName[i],
		}
	}
	return results, nil
}

func GetPost(ctx context.Context, db neogo.Driver, id int) ([]*getPostResult, error) {
	return getPostImpl(ctx, db, id)
}

var getPostImpl func(context.Context, neogo.Driver, int) ([]*getPostResult, error) = getPostProd

func getPostProd(ctx context.Context, db neogo.Driver, id int) ([]*getPostResult, error) {
	var rowsID []int
	var rowsContent []string
	var rowsCreatedAt []int
	var rowsAuthorId []int
	var rowsAuthorName []string
	err := db.Exec().
		Cypher(`MATCH (u:User)-[:AUTHORED]->(p:Post {id: $id})
	RETURN p.id, p.content, p.createdAt, u.id as authorId, u.name as authorName`).
		RunWithParams(ctx, map[string]any{"id": id}, "p.id", &rowsID, "p.content", &rowsContent, "p.createdAt", &rowsCreatedAt, "authorId", &rowsAuthorId, "authorName", &rowsAuthorName)
	if err != nil {
		return nil, err
	}
	results := make([]*getPostResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getPostResult{
			ID:         rowsID[i],
			Content:    rowsContent[i],
			CreatedAt:  rowsCreatedAt[i],
			AuthorId:   rowsAuthorId[i],
			AuthorName: rowsAuthorName[i],
		}
	}
	return results, nil
}

func GetUserPosts(ctx context.Context, db neogo.Driver, userId int) ([]*getUserPostsResult, error) {
	return getUserPostsImpl(ctx, db, userId)
}

var getUserPostsImpl func(context.Context, neogo.Driver, int) ([]*getUserPostsResult, error) = getUserPostsProd

func getUserPostsProd(ctx context.Context, db neogo.Driver, userId int) ([]*getUserPostsResult, error) {
	var rowsID []int
	var rowsContent []string
	var rowsCreatedAt []int
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $userId})-[:AUTHORED]->(p:Post)
	RETURN p.id, p.content, p.createdAt
	ORDER BY p.createdAt DESC`).
		RunWithParams(ctx, map[string]any{"userId": userId}, "p.id", &rowsID, "p.content", &rowsContent, "p.createdAt", &rowsCreatedAt)
	if err != nil {
		return nil, err
	}
	results := make([]*getUserPostsResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getUserPostsResult{
			ID:        rowsID[i],
			Content:   rowsContent[i],
			CreatedAt: rowsCreatedAt[i],
		}
	}
	return results, nil
}

func DeletePost(ctx context.Context, db neogo.Driver, id int) ([]int, error) {
	return deletePostImpl(ctx, db, id)
}

var deletePostImpl func(context.Context, neogo.Driver, int) ([]int, error) = deletePostProd

func deletePostProd(ctx context.Context, db neogo.Driver, id int) ([]int, error) {
	var rowsDeleted []int
	err := db.Exec().
		Cypher(`MATCH (p:Post {id: $id})
	DETACH DELETE p
	RETURN count(p) as deleted`).
		RunWithParams(ctx, map[string]any{"id": id}, "deleted", &rowsDeleted)
	if err != nil {
		return nil, err
	}
	return rowsDeleted, nil
}

func LikePost(ctx context.Context, db neogo.Driver, userId int, postId int) ([]int, error) {
	return likePostImpl(ctx, db, userId, postId)
}

var likePostImpl func(context.Context, neogo.Driver, int, int) ([]int, error) = likePostProd

func likePostProd(ctx context.Context, db neogo.Driver, userId int, postId int) ([]int, error) {
	var rowsLiked []int
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $userId}), (p:Post {id: $postId})
	MERGE (u)-[l:LIKED]->(p)
	ON CREATE SET l.createdAt = timestamp()
	RETURN count(l) as liked`).
		RunWithParams(ctx, map[string]any{"userId": userId, "postId": postId}, "liked", &rowsLiked)
	if err != nil {
		return nil, err
	}
	return rowsLiked, nil
}

func GetPostLikes(ctx context.Context, db neogo.Driver, postId int) ([]*getPostLikesResult, error) {
	return getPostLikesImpl(ctx, db, postId)
}

var getPostLikesImpl func(context.Context, neogo.Driver, int) ([]*getPostLikesResult, error) = getPostLikesProd

func getPostLikesProd(ctx context.Context, db neogo.Driver, postId int) ([]*getPostLikesResult, error) {
	var rowsLikeCount []int
	var rowsLikers [][]string
	err := db.Exec().
		Cypher(`MATCH (u:User)-[:LIKED]->(p:Post {id: $postId})
	RETURN count(u) as likeCount, collect(u.name) as likers`).
		RunWithParams(ctx, map[string]any{"postId": postId}, "likeCount", &rowsLikeCount, "likers", &rowsLikers)
	if err != nil {
		return nil, err
	}
	results := make([]*getPostLikesResult, len(rowsLikeCount))
	for i := range rowsLikeCount {
		results[i] = &getPostLikesResult{
			LikeCount: rowsLikeCount[i],
			Likers:    rowsLikers[i],
		}
	}
	return results, nil
}

func CountUserPosts(ctx context.Context, db neogo.Driver, userId int) ([]int, error) {
	return countUserPostsImpl(ctx, db, userId)
}

var countUserPostsImpl func(context.Context, neogo.Driver, int) ([]int, error) = countUserPostsProd

func countUserPostsProd(ctx context.Context, db neogo.Driver, userId int) ([]int, error) {
	var rowsCount []int
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $userId})-[:AUTHORED]->(p:Post)
	RETURN count(p) as count`).
		RunWithParams(ctx, map[string]any{"userId": userId}, "count", &rowsCount)
	if err != nil {
		return nil, err
	}
	return rowsCount, nil
}

func HasLiked(ctx context.Context, db neogo.Driver, userId int, postId int) ([]bool, error) {
	return hasLikedImpl(ctx, db, userId, postId)
}

var hasLikedImpl func(context.Context, neogo.Driver, int, int) ([]bool, error) = hasLikedProd

func hasLikedProd(ctx context.Context, db neogo.Driver, userId int, postId int) ([]bool, error) {
	var rowsHasLiked []bool
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $userId})-[:LIKED]->(p:Post {id: $postId})
	RETURN count(*) > 0 as hasLiked`).
		RunWithParams(ctx, map[string]any{"userId": userId, "postId": postId}, "hasLiked", &rowsHasLiked)
	if err != nil {
		return nil, err
	}
	return rowsHasLiked, nil
}

func CreateUser(ctx context.Context, db neogo.Driver, id int, name string, email string, createdAt int) ([]*createUserResult, error) {
	return createUserImpl(ctx, db, id, name, email, createdAt)
}

var createUserImpl func(context.Context, neogo.Driver, int, string, string, int) ([]*createUserResult, error) = createUserProd

func createUserProd(ctx context.Context, db neogo.Driver, id int, name string, email string, createdAt int) ([]*createUserResult, error) {
	var rowsID []int
	var rowsName []string
	var rowsEmail []string
	err := db.Exec().
		Cypher(`CREATE (u:User {id: $id, name: $name, email: $email, createdAt: $createdAt})
	RETURN u.id, u.name, u.email`).
		RunWithParams(ctx, map[string]any{"id": id, "name": name, "email": email, "createdAt": createdAt}, "u.id", &rowsID, "u.name", &rowsName, "u.email", &rowsEmail)
	if err != nil {
		return nil, err
	}
	results := make([]*createUserResult, len(rowsID))
	for i := range rowsID {
		results[i] = &createUserResult{
			ID:    rowsID[i],
			Name:  rowsName[i],
			Email: rowsEmail[i],
		}
	}
	return results, nil
}

func GetUserById(ctx context.Context, db neogo.Driver, id int) ([]*getUserByIdResult, error) {
	return getUserByIdImpl(ctx, db, id)
}

var getUserByIdImpl func(context.Context, neogo.Driver, int) ([]*getUserByIdResult, error) = getUserByIdProd

func getUserByIdProd(ctx context.Context, db neogo.Driver, id int) ([]*getUserByIdResult, error) {
	var rowsID []int
	var rowsName []string
	var rowsEmail []string
	var rowsCreatedAt []int
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $id})
	RETURN u.id, u.name, u.email, u.createdAt`).
		RunWithParams(ctx, map[string]any{"id": id}, "u.id", &rowsID, "u.name", &rowsName, "u.email", &rowsEmail, "u.createdAt", &rowsCreatedAt)
	if err != nil {
		return nil, err
	}
	results := make([]*getUserByIdResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getUserByIdResult{
			ID:        rowsID[i],
			Name:      rowsName[i],
			Email:     rowsEmail[i],
			CreatedAt: rowsCreatedAt[i],
		}
	}
	return results, nil
}

func GetUserByEmail(ctx context.Context, db neogo.Driver, email string) ([]*getUserByEmailResult, error) {
	return getUserByEmailImpl(ctx, db, email)
}

var getUserByEmailImpl func(context.Context, neogo.Driver, string) ([]*getUserByEmailResult, error) = getUserByEmailProd

func getUserByEmailProd(ctx context.Context, db neogo.Driver, email string) ([]*getUserByEmailResult, error) {
	var rowsID []int
	var rowsName []string
	var rowsEmail []string
	err := db.Exec().
		Cypher(`MATCH (u:User {email: $email})
	RETURN u.id, u.name, u.email`).
		RunWithParams(ctx, map[string]any{"email": email}, "u.id", &rowsID, "u.name", &rowsName, "u.email", &rowsEmail)
	if err != nil {
		return nil, err
	}
	results := make([]*getUserByEmailResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getUserByEmailResult{
			ID:    rowsID[i],
			Name:  rowsName[i],
			Email: rowsEmail[i],
		}
	}
	return results, nil
}

func ListUsers(ctx context.Context, db neogo.Driver) ([]*listUsersResult, error) {
	return listUsersImpl(ctx, db)
}

var listUsersImpl func(context.Context, neogo.Driver) ([]*listUsersResult, error) = listUsersProd

func listUsersProd(ctx context.Context, db neogo.Driver) ([]*listUsersResult, error) {
	var rowsID []int
	var rowsName []string
	var rowsEmail []string
	err := db.Exec().
		Cypher(`MATCH (u:User)
	RETURN u.id, u.name, u.email
	ORDER BY u.createdAt DESC`).
		Run(ctx, "u.id", &rowsID, "u.name", &rowsName, "u.email", &rowsEmail)
	if err != nil {
		return nil, err
	}
	results := make([]*listUsersResult, len(rowsID))
	for i := range rowsID {
		results[i] = &listUsersResult{
			ID:    rowsID[i],
			Name:  rowsName[i],
			Email: rowsEmail[i],
		}
	}
	return results, nil
}

func UpdateUser(ctx context.Context, db neogo.Driver, id int, name string, email string) ([]*updateUserResult, error) {
	return updateUserImpl(ctx, db, id, name, email)
}

var updateUserImpl func(context.Context, neogo.Driver, int, string, string) ([]*updateUserResult, error) = updateUserProd

func updateUserProd(ctx context.Context, db neogo.Driver, id int, name string, email string) ([]*updateUserResult, error) {
	var rowsID []int
	var rowsName []string
	var rowsEmail []string
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $id})
	SET u.name = $name, u.email = $email
	RETURN u.id, u.name, u.email`).
		RunWithParams(ctx, map[string]any{"id": id, "name": name, "email": email}, "u.id", &rowsID, "u.name", &rowsName, "u.email", &rowsEmail)
	if err != nil {
		return nil, err
	}
	results := make([]*updateUserResult, len(rowsID))
	for i := range rowsID {
		results[i] = &updateUserResult{
			ID:    rowsID[i],
			Name:  rowsName[i],
			Email: rowsEmail[i],
		}
	}
	return results, nil
}

func DeleteUser(ctx context.Context, db neogo.Driver, id int) ([]int, error) {
	return deleteUserImpl(ctx, db, id)
}

var deleteUserImpl func(context.Context, neogo.Driver, int) ([]int, error) = deleteUserProd

func deleteUserProd(ctx context.Context, db neogo.Driver, id int) ([]int, error) {
	var rowsDeleted []int
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $id})
	DETACH DELETE u
	RETURN count(u) as deleted`).
		RunWithParams(ctx, map[string]any{"id": id}, "deleted", &rowsDeleted)
	if err != nil {
		return nil, err
	}
	return rowsDeleted, nil
}

func CountUsers(ctx context.Context, db neogo.Driver) ([]int, error) {
	return countUsersImpl(ctx, db)
}

var countUsersImpl func(context.Context, neogo.Driver) ([]int, error) = countUsersProd

func countUsersProd(ctx context.Context, db neogo.Driver) ([]int, error) {
	var rowsCount []int
	err := db.Exec().
		Cypher(`MATCH (u:User)
	RETURN count(u) as count`).
		Run(ctx, "count", &rowsCount)
	if err != nil {
		return nil, err
	}
	return rowsCount, nil
}
