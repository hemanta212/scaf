// Code generated by scaf. DO NOT EDIT.

package db

import (
	"context"

	"github.com/rlch/neogo"
)

type createUserResult struct {
	ID    int
	Name  string
	Email string
}

type getUserByIdResult struct {
	ID        int
	Name      string
	Email     string
	CreatedAt int
}

type getUserByEmailResult struct {
	ID    int
	Name  string
	Email string
}

type listUsersResult struct {
	ID    int
	Name  string
	Email string
}

type updateUserResult struct {
	ID    int
	Name  string
	Email string
}

func CreateUser(ctx context.Context, db neogo.Driver, id int, name string, email string, createdAt int) ([]*createUserResult, error) {
	return createUserImpl(ctx, db, id, name, email, createdAt)
}

var createUserImpl func(context.Context, neogo.Driver, int, string, string, int) ([]*createUserResult, error) = createUserProd

func createUserProd(ctx context.Context, db neogo.Driver, id int, name string, email string, createdAt int) ([]*createUserResult, error) {
	var rowsID []int
	var rowsName []string
	var rowsEmail []string
	err := db.Exec().
		Cypher(`CREATE (u:User {id: $id, name: $name, email: $email, createdAt: $createdAt})
	RETURN u.id, u.name, u.email`).
		RunWithParams(ctx, map[string]any{"id": id, "name": name, "email": email, "createdAt": createdAt}, "u.id", &rowsID, "u.name", &rowsName, "u.email", &rowsEmail)
	if err != nil {
		return nil, err
	}
	results := make([]*createUserResult, len(rowsID))
	for i := range rowsID {
		results[i] = &createUserResult{
			ID:    rowsID[i],
			Name:  rowsName[i],
			Email: rowsEmail[i],
		}
	}
	return results, nil
}

func GetUserById(ctx context.Context, db neogo.Driver, id int) ([]*getUserByIdResult, error) {
	return getUserByIdImpl(ctx, db, id)
}

var getUserByIdImpl func(context.Context, neogo.Driver, int) ([]*getUserByIdResult, error) = getUserByIdProd

func getUserByIdProd(ctx context.Context, db neogo.Driver, id int) ([]*getUserByIdResult, error) {
	var rowsID []int
	var rowsName []string
	var rowsEmail []string
	var rowsCreatedAt []int
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $id})
	RETURN u.id, u.name, u.email, u.createdAt`).
		RunWithParams(ctx, map[string]any{"id": id}, "u.id", &rowsID, "u.name", &rowsName, "u.email", &rowsEmail, "u.createdAt", &rowsCreatedAt)
	if err != nil {
		return nil, err
	}
	results := make([]*getUserByIdResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getUserByIdResult{
			ID:        rowsID[i],
			Name:      rowsName[i],
			Email:     rowsEmail[i],
			CreatedAt: rowsCreatedAt[i],
		}
	}
	return results, nil
}

func GetUserByEmail(ctx context.Context, db neogo.Driver, email string) ([]*getUserByEmailResult, error) {
	return getUserByEmailImpl(ctx, db, email)
}

var getUserByEmailImpl func(context.Context, neogo.Driver, string) ([]*getUserByEmailResult, error) = getUserByEmailProd

func getUserByEmailProd(ctx context.Context, db neogo.Driver, email string) ([]*getUserByEmailResult, error) {
	var rowsID []int
	var rowsName []string
	var rowsEmail []string
	err := db.Exec().
		Cypher(`MATCH (u:User {email: $email})
	RETURN u.id, u.name, u.email`).
		RunWithParams(ctx, map[string]any{"email": email}, "u.id", &rowsID, "u.name", &rowsName, "u.email", &rowsEmail)
	if err != nil {
		return nil, err
	}
	results := make([]*getUserByEmailResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getUserByEmailResult{
			ID:    rowsID[i],
			Name:  rowsName[i],
			Email: rowsEmail[i],
		}
	}
	return results, nil
}

func ListUsers(ctx context.Context, db neogo.Driver) ([]*listUsersResult, error) {
	return listUsersImpl(ctx, db)
}

var listUsersImpl func(context.Context, neogo.Driver) ([]*listUsersResult, error) = listUsersProd

func listUsersProd(ctx context.Context, db neogo.Driver) ([]*listUsersResult, error) {
	var rowsID []int
	var rowsName []string
	var rowsEmail []string
	err := db.Exec().
		Cypher(`MATCH (u:User)
	RETURN u.id, u.name, u.email
	ORDER BY u.createdAt DESC`).
		Run(ctx, "u.id", &rowsID, "u.name", &rowsName, "u.email", &rowsEmail)
	if err != nil {
		return nil, err
	}
	results := make([]*listUsersResult, len(rowsID))
	for i := range rowsID {
		results[i] = &listUsersResult{
			ID:    rowsID[i],
			Name:  rowsName[i],
			Email: rowsEmail[i],
		}
	}
	return results, nil
}

func UpdateUser(ctx context.Context, db neogo.Driver, id int, name string, email string) ([]*updateUserResult, error) {
	return updateUserImpl(ctx, db, id, name, email)
}

var updateUserImpl func(context.Context, neogo.Driver, int, string, string) ([]*updateUserResult, error) = updateUserProd

func updateUserProd(ctx context.Context, db neogo.Driver, id int, name string, email string) ([]*updateUserResult, error) {
	var rowsID []int
	var rowsName []string
	var rowsEmail []string
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $id})
	SET u.name = $name, u.email = $email
	RETURN u.id, u.name, u.email`).
		RunWithParams(ctx, map[string]any{"id": id, "name": name, "email": email}, "u.id", &rowsID, "u.name", &rowsName, "u.email", &rowsEmail)
	if err != nil {
		return nil, err
	}
	results := make([]*updateUserResult, len(rowsID))
	for i := range rowsID {
		results[i] = &updateUserResult{
			ID:    rowsID[i],
			Name:  rowsName[i],
			Email: rowsEmail[i],
		}
	}
	return results, nil
}

func DeleteUser(ctx context.Context, db neogo.Driver, id int) ([]int, error) {
	return deleteUserImpl(ctx, db, id)
}

var deleteUserImpl func(context.Context, neogo.Driver, int) ([]int, error) = deleteUserProd

func deleteUserProd(ctx context.Context, db neogo.Driver, id int) ([]int, error) {
	var rowsDeleted []int
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $id})
	DETACH DELETE u
	RETURN count(u) as deleted`).
		RunWithParams(ctx, map[string]any{"id": id}, "deleted", &rowsDeleted)
	if err != nil {
		return nil, err
	}
	return rowsDeleted, nil
}

func CountUsers(ctx context.Context, db neogo.Driver) ([]int, error) {
	return countUsersImpl(ctx, db)
}

var countUsersImpl func(context.Context, neogo.Driver) ([]int, error) = countUsersProd

func countUsersProd(ctx context.Context, db neogo.Driver) ([]int, error) {
	var rowsCount []int
	err := db.Exec().
		Cypher(`MATCH (u:User)
	RETURN count(u) as count`).
		Run(ctx, "count", &rowsCount)
	if err != nil {
		return nil, err
	}
	return rowsCount, nil
}
