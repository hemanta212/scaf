# PRD: Multi-Package Support with Same-Directory File Merging

<!-- Thread: T-019b9974-f6d1-72b9-878a-58d488781789, T-019bb083-728f-70ce-9a30-5cdd1c2a1409 -->

## Problem

1. **File overwrite**: Multiple `.scaf` files in same directory overwrite `scaf.go` - only last file's functions survive
2. **Same-package imports**: Sibling `.scaf` files importing each other create redundant imports after merge
3. **Package naming**: Current logic in `cmd/scaf/generate.go:283-292` uses naive folder sanitization, ignoring existing Go package declarations
4. **Config discovery**: Config lookup only checks input file's directory, doesn't walk up to find project root config

## Root Cause Analysis

### File Overwrite (fixed in commit afdd5f3, needs enhancement)

**Location**: `cmd/scaf/generate.go:256-281`

Current merge logic concatenates without deduplication:
```go
// Line 271-273 - just appends, no dedup
merged.Imports = append(merged.Imports, suite.Imports...)
merged.Functions = append(merged.Functions, suite.Functions...)
```

### Package Naming (wrong layer)

**Location**: `cmd/scaf/generate.go:283-292`

```go
// Go-specific logic in language-agnostic cmd layer - WRONG
packageName = filepath.Base(outputDir)
packageName = strings.ReplaceAll(packageName, "-", "")
```

This belongs in `language/go/` since package naming is language-specific.

### Config Discovery (wrong scope)

**Location**: `cmd/scaf/generate.go:92-100`

```go
// Line 92-100 - only checks first file's directory, no walk-up
configDir := filepath.Dir(files[0])
loadedCfg, err := scaf.LoadConfig(configDir)
```

**Problem**: Current behavior requires specifying individual files/dirs. Expected behavior is `go generate ./...` style:

```bash
# Current (broken)
scaf generate internal/users/  # looks for config in internal/users/

# Expected (like go generate)
scaf generate                  # from project root, finds all packages
```

**Expected flow**:
1. Run `scaf generate` from project root
2. Load `.scaf.yaml` from cwd
3. Load `.scaf-schema.yaml` relative to config file
4. Walk all subdirs, find `*.scaf` files
5. Group by directory (each dir = one package)
6. For each package: merge files, infer package name, generate

## Solution Architecture

### Layer Responsibilities

| Layer | File | Responsibility |
|-------|------|----------------|
| module | `module/merge.go` (new) | Merge scaf ASTs, dedupe imports, detect duplicates |
| analysis | `analysis/rules.go` | Warn on same-package imports |
| language/go | `language/go/package.go` (new) | Infer Go package name from dir |
| cmd | `cmd/scaf/generate.go` | Orchestration only |
| cmd | `cmd/scaf/config.go` | Walk up to find `.scaf.yaml`, track config dir for relative paths |

## Detailed Implementation

### 1. module/merge.go (new file)

**Purpose**: Language-agnostic merging of scaf files in same package.

**Reference**: Current merge logic at `cmd/scaf/generate.go:256-281`

```go
package module

import (
    "fmt"
    "path/filepath"
    
    "github.com/rlch/scaf"
)

// MergeWarning represents a non-fatal issue found during merge.
type MergeWarning struct {
    File    string
    Message string
}

// MergeResult contains the merged file and any warnings.
type MergeResult struct {
    File     *scaf.File
    Warnings []MergeWarning
}

// MergePackageFiles merges multiple scaf files from same directory into one.
// 
// It handles:
// - Import deduplication (same alias+path = single import)
// - Same-package import detection (import pointing to sibling file)
// - Duplicate function detection (error if same fn name in multiple files)
// - Setup/Teardown conflict detection (warn if multiple, keep first)
//
// Reference: Original merge at cmd/scaf/generate.go:256-281
func MergePackageFiles(inputFiles []string, parsedFiles []*scaf.File) (*MergeResult, error) {
    if len(inputFiles) != len(parsedFiles) {
        return nil, fmt.Errorf("inputFiles and parsedFiles length mismatch")
    }
    
    result := &MergeResult{
        File: &scaf.File{},
    }
    
    // Track sibling files for same-package import detection
    siblingBases := make(map[string]bool)
    for _, f := range inputFiles {
        base := filepath.Base(f)
        baseNoExt := base[:len(base)-len(filepath.Ext(base))]
        siblingBases[baseNoExt] = true
        siblingBases[base] = true
        siblingBases["./"+base] = true
        siblingBases["./"+baseNoExt] = true
    }
    
    // Track seen imports: key = "alias:resolvedPath"
    seenImports := make(map[string]bool)
    
    // Track function names to detect duplicates
    fnSources := make(map[string]string) // fnName -> sourceFile
    
    for i, suite := range parsedFiles {
        inputFile := inputFiles[i]
        
        // Process imports
        for _, imp := range suite.Imports {
            // Check if import points to sibling file
            if isSamePackageImport(imp.Path, siblingBases) {
                result.Warnings = append(result.Warnings, MergeWarning{
                    File:    inputFile,
                    Message: fmt.Sprintf("import %q points to same-package file (unnecessary)", imp.Path),
                })
                continue // Skip this import
            }
            
            // Deduplicate by alias + path
            key := imp.Alias + ":" + imp.Path
            if !seenImports[key] {
                seenImports[key] = true
                result.File.Imports = append(result.File.Imports, imp)
            }
        }
        
        // Process functions - check for duplicates
        for _, fn := range suite.Functions {
            if existingFile, exists := fnSources[fn.Name]; exists {
                return nil, fmt.Errorf("duplicate function %q: defined in %s and %s",
                    fn.Name, existingFile, inputFile)
            }
            fnSources[fn.Name] = inputFile
            result.File.Functions = append(result.File.Functions, fn)
        }
        
        // Merge scopes
        result.File.Scopes = append(result.File.Scopes, suite.Scopes...)
        
        // Setup/Teardown: keep first, warn on conflicts
        if suite.Setup != nil {
            if result.File.Setup != nil {
                result.Warnings = append(result.Warnings, MergeWarning{
                    File:    inputFile,
                    Message: "multiple setup clauses; using first, ignoring this one",
                })
            } else {
                result.File.Setup = suite.Setup
            }
        }
        if suite.Teardown != nil {
            if result.File.Teardown != nil {
                result.Warnings = append(result.Warnings, MergeWarning{
                    File:    inputFile,
                    Message: "multiple teardown clauses; using first, ignoring this one",
                })
            } else {
                result.File.Teardown = suite.Teardown
            }
        }
    }
    
    return result, nil
}

// isSamePackageImport checks if an import path points to a sibling file.
func isSamePackageImport(importPath string, siblingBases map[string]bool) bool {
    // Direct match
    if siblingBases[importPath] {
        return true
    }
    // Check base name
    base := filepath.Base(importPath)
    if siblingBases[base] {
        return true
    }
    // Check without extension
    baseNoExt := base[:len(base)-len(filepath.Ext(base))]
    return siblingBases[baseNoExt]
}
```

### 2. language/go/package.go (new file)

**Purpose**: Go-specific package name inference.

**Reference**: Discussion in T-019bb083-728f-70ce-9a30-5cdd1c2a1409 about `go/build.ImportDir`

```go
package golang

import (
    "go/build"
    "go/parser"
    "go/token"
    "os"
    "path/filepath"
    "strings"
    "unicode"
)

// InferPackageName determines the Go package name for a directory.
//
// Detection ladder (highest to lowest priority):
// 1. go/build.ImportDir - respects build tags, returns pkg.Name
// 2. parser.PackageClauseOnly - parses any .go file for "package X"
// 3. Sanitized folder name - fallback when no Go files exist
//
// Reference: go/build docs at https://pkg.go.dev/go/build
// Reference: go/parser docs at https://pkg.go.dev/go/parser
func InferPackageName(dir string) string {
    // Step 1: go/build.ImportDir (respects build tags)
    if p, err := build.Default.ImportDir(dir, 0); err == nil && p.Name != "" {
        return p.Name
    }
    
    // Step 2: Parse any .go file's package clause
    // Catches files hidden by build tags
    if name := parseAnyPackageClause(dir); name != "" {
        return name
    }
    
    // Step 3: Sanitize folder name
    return SanitizePackageName(filepath.Base(dir))
}

// parseAnyPackageClause scans .go files for package declarations.
// Skips _test.go files. Returns first found package name.
func parseAnyPackageClause(dir string) string {
    entries, err := os.ReadDir(dir)
    if err != nil {
        return ""
    }
    
    fset := token.NewFileSet()
    
    for _, e := range entries {
        name := e.Name()
        if e.IsDir() || !strings.HasSuffix(name, ".go") {
            continue
        }
        if strings.HasSuffix(name, "_test.go") {
            continue
        }
        
        f, err := parser.ParseFile(fset, filepath.Join(dir, name), nil, parser.PackageClauseOnly)
        if err == nil && f.Name != nil {
            return f.Name.Name
        }
    }
    return ""
}

// SanitizePackageName converts a string to a valid Go package name.
//
// Rules applied:
// - Lowercase
// - Remove hyphens, underscores, dots
// - Prefix with underscore if starts with digit
// - Avoid Go keywords
//
// Reference: Go spec https://go.dev/ref/spec#identifier
// Reference: Effective Go https://go.dev/doc/effective_go#package-names
func SanitizePackageName(name string) string {
    var b strings.Builder
    
    for _, r := range name {
        switch {
        case r >= 'a' && r <= 'z':
            b.WriteRune(r)
        case r >= 'A' && r <= 'Z':
            b.WriteRune(unicode.ToLower(r))
        case r >= '0' && r <= '9':
            b.WriteRune(r)
        // Skip hyphens, underscores, dots, etc.
        }
    }
    
    result := b.String()
    if result == "" {
        return "main"
    }
    
    // Can't start with digit
    if result[0] >= '0' && result[0] <= '9' {
        result = "pkg" + result
    }
    
    // Avoid Go keywords (simplified check)
    keywords := map[string]bool{
        "break": true, "case": true, "chan": true, "const": true,
        "continue": true, "default": true, "defer": true, "else": true,
        "fallthrough": true, "for": true, "func": true, "go": true,
        "goto": true, "if": true, "import": true, "interface": true,
        "map": true, "package": true, "range": true, "return": true,
        "select": true, "struct": true, "switch": true, "type": true,
        "var": true,
    }
    if keywords[result] {
        result = result + "pkg"
    }
    
    return result
}
```

### 3. cmd/scaf/generate.go updates

**Purpose**: New `go generate ./...` style flow - run from project root, discover all packages.

**Reference**: Current implementation at `cmd/scaf/generate.go:75-243`

```go
func runGenerate(ctx context.Context, cmd *cli.Command) error {
    // Step 1: Load config from cwd (project root)
    cwd, err := os.Getwd()
    if err != nil {
        return fmt.Errorf("getting cwd: %w", err)
    }
    
    cfg, err := scaf.LoadConfig(cwd)
    if err != nil {
        return fmt.Errorf("loading config: %w (run from project root with .scaf.yaml)", err)
    }
    
    // Step 2: Load schema relative to config file location (cwd)
    var schema *analysis.TypeSchema
    if cfg.Generate.Schema != "" {
        schemaPath := filepath.Join(cwd, cfg.Generate.Schema)
        schema, err = analysis.LoadSchema(schemaPath, cwd)
        if err != nil {
            return fmt.Errorf("loading schema: %w", err)
        }
    }
    
    // Step 3: Discover all .scaf files, group by directory
    packages, err := discoverPackages(cwd)
    if err != nil {
        return fmt.Errorf("discovering packages: %w", err)
    }
    
    if len(packages) == 0 {
        return fmt.Errorf("no .scaf files found under %s", cwd)
    }
    
    // Step 4: Get language/adapter (from config or defaults)
    langName := firstNonEmpty(cmd.String("lang"), cfg.Generate.Lang, scaf.LangGo)
    adapterName := firstNonEmpty(cmd.String("adapter"), cfg.Generate.Adapter, scaf.AdapterNeogo)
    
    goLang := language.Get(langName).(*golang.GoLanguage)
    binding := golang.GetBinding(adapterName)
    queryAnalyzer := scaf.GetAnalyzer(cfg.DialectName())
    
    // Step 5: Generate each package
    for pkgDir, scafFiles := range packages {
        // Parse all files in package
        var parsedFiles []*scaf.File
        for _, f := range scafFiles {
            data, _ := os.ReadFile(f)
            suite, _ := scaf.Parse(data)
            parsedFiles = append(parsedFiles, suite)
        }
        
        // Merge using module layer
        mergeResult, err := module.MergePackageFiles(scafFiles, parsedFiles)
        if err != nil {
            return fmt.Errorf("merging %s: %w", pkgDir, err)
        }
        
        // Print warnings
        for _, w := range mergeResult.Warnings {
            fmt.Fprintf(os.Stderr, "warning: %s: %s\n", w.File, w.Message)
        }
        
        // Infer package name using language layer
        packageName := golang.InferPackageName(pkgDir)
        
        // Generate
        goCtx := &golang.Context{
            GenerateContext: language.GenerateContext{
                Suite:         mergeResult.File,
                QueryAnalyzer: queryAnalyzer,
                Schema:        schema,
                OutputDir:     pkgDir,
            },
            PackageName: packageName,
            Binding:     binding,
        }
        
        files, err := goLang.GenerateWithContext(goCtx)
        if err != nil {
            return fmt.Errorf("generating %s: %w", pkgDir, err)
        }
        
        for filename, content := range files {
            if content == nil {
                continue
            }
            outPath := filepath.Join(pkgDir, filename)
            os.WriteFile(outPath, content, 0o644)
            fmt.Printf("wrote %s\n", outPath)
        }
    }
    
    return nil
}

// discoverPackages walks cwd and finds all directories containing .scaf files.
// Returns map[directory][]scafFiles
func discoverPackages(root string) (map[string][]string, error) {
    packages := make(map[string][]string)
    
    err := filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {
        if err != nil {
            return err
        }
        // Skip hidden directories and common non-source dirs
        if d.IsDir() && (strings.HasPrefix(d.Name(), ".") || d.Name() == "vendor" || d.Name() == "node_modules") {
            return filepath.SkipDir
        }
        if !d.IsDir() && strings.HasSuffix(path, ".scaf") {
            dir := filepath.Dir(path)
            packages[dir] = append(packages[dir], path)
        }
        return nil
    })
    
    return packages, err
}

func firstNonEmpty(values ...string) string {
    for _, v := range values {
        if v != "" {
            return v
        }
    }
    return ""
}
```

### 4. analysis/rules.go addition

**Purpose**: Semantic warning for same-package imports during analysis.

**Reference**: Current rules at `analysis/rules.go`

```go
// checkSamePackageImport warns when an import points to a sibling file.
// This is called during LSP analysis, not during generate (which handles it in merge).
//
// Reference: Current diagnostic emission at analysis/rules.go
func (a *Analyzer) checkSamePackageImport(file *scaf.File, filePath string) {
    dir := filepath.Dir(filePath)
    
    // Find sibling .scaf files
    siblings := make(map[string]bool)
    entries, _ := os.ReadDir(dir)
    for _, e := range entries {
        if !e.IsDir() && strings.HasSuffix(e.Name(), ".scaf") && e.Name() != filepath.Base(filePath) {
            base := e.Name()
            baseNoExt := base[:len(base)-5] // strip .scaf
            siblings[base] = true
            siblings[baseNoExt] = true
            siblings["./"+base] = true
            siblings["./"+baseNoExt] = true
        }
    }
    
    for _, imp := range file.Imports {
        if isSamePackageImport(imp.Path, siblings) {
            a.addDiagnostic(Diagnostic{
                Severity: Warning,
                Message:  fmt.Sprintf("importing %q from same package is unnecessary; functions are directly available", imp.Path),
                Span:     imp.Meta().Span,
            })
        }
    }
}
```

## Testing Strategy

### Unit Tests

1. **module/merge_test.go**:
   - Merge two files with no overlap
   - Merge with duplicate imports (should dedupe)
   - Merge with same-package import (should warn + skip)
   - Merge with duplicate function names (should error)
   - Merge with conflicting setup/teardown (should warn)

2. **language/go/package_test.go**:
   - Dir with Go files → parse package name
   - Dir with build-tag-hidden files → fallback to PackageClauseOnly
   - Dir with no Go files → sanitize folder name
   - Folder names with hyphens, dots, digits

### Integration Tests

1. **example/repro-multi-package/**:
   - Run `scaf generate internal/users/`
   - Verify `scaf.go` contains all functions from both files
   - Verify warning about same-package import
   - Verify `go build` succeeds

## File References

| File | Lines | What |
|------|-------|------|
| `cmd/scaf/generate.go` | 225-240 | Current grouping logic |
| `cmd/scaf/generate.go` | 256-281 | Current merge logic (to refactor) |
| `cmd/scaf/generate.go` | 283-292 | Current package naming (to move) |
| `module/loader.go` | 30-55 | Loader pattern to follow |
| `analysis/rules.go` | - | Diagnostic emission pattern |
| `ast.go` | 1-80 | File/Import/Function types |

## Checklist

- [ ] Create `module/merge.go` with `MergePackageFiles()`
- [ ] Create `module/merge_test.go`
- [ ] Create `language/go/package.go` with `InferPackageName()`
- [ ] Create `language/go/package_test.go`
- [ ] Update `cmd/scaf/generate.go` to use new functions
- [ ] Add same-package import warning to `analysis/rules.go`
- [ ] Verify `example/repro-multi-package/` works
- [ ] Run `go test ./...`
