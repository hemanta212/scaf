# PRD: Multi-Package Support with Same-Directory File Merging

<!-- Thread: T-019b9974-f6d1-72b9-878a-58d488781789, T-019bb083-728f-70ce-9a30-5cdd1c2a1409 -->

## Problem

1. **File overwrite**: Multiple `.scaf` files in same directory overwrite `scaf.go` - only last file's functions survive
2. **Same-package imports**: Sibling `.scaf` files importing each other create redundant imports after merge
3. **Package naming**: Current logic in `cmd/scaf/generate.go:283-292` uses naive folder sanitization, ignoring existing Go package declarations

## Root Cause Analysis

### File Overwrite (fixed in commit afdd5f3, needs enhancement)

**Location**: `cmd/scaf/generate.go:256-281`

Current merge logic concatenates without deduplication:
```go
// Line 271-273 - just appends, no dedup
merged.Imports = append(merged.Imports, suite.Imports...)
merged.Functions = append(merged.Functions, suite.Functions...)
```

### Package Naming (wrong layer)

**Location**: `cmd/scaf/generate.go:283-292`

```go
// Go-specific logic in language-agnostic cmd layer - WRONG
packageName = filepath.Base(outputDir)
packageName = strings.ReplaceAll(packageName, "-", "")
```

This belongs in `language/go/` since package naming is language-specific.

## Solution Architecture

### Layer Responsibilities

| Layer | File | Responsibility |
|-------|------|----------------|
| module | `module/merge.go` (new) | Merge scaf ASTs, dedupe imports, detect duplicates |
| analysis | `analysis/rules.go` | Warn on same-package imports |
| language/go | `language/go/package.go` (new) | Infer Go package name from dir |
| cmd | `cmd/scaf/generate.go` | Orchestration only |

## Detailed Implementation

### 1. module/merge.go (new file)

**Purpose**: Language-agnostic merging of scaf files in same package.

**Reference**: Current merge logic at `cmd/scaf/generate.go:256-281`

```go
package module

import (
    "fmt"
    "path/filepath"
    
    "github.com/rlch/scaf"
)

// MergeWarning represents a non-fatal issue found during merge.
type MergeWarning struct {
    File    string
    Message string
}

// MergeResult contains the merged file and any warnings.
type MergeResult struct {
    File     *scaf.File
    Warnings []MergeWarning
}

// MergePackageFiles merges multiple scaf files from same directory into one.
// 
// It handles:
// - Import deduplication (same alias+path = single import)
// - Same-package import detection (import pointing to sibling file)
// - Duplicate function detection (error if same fn name in multiple files)
// - Setup/Teardown conflict detection (warn if multiple, keep first)
//
// Reference: Original merge at cmd/scaf/generate.go:256-281
func MergePackageFiles(inputFiles []string, parsedFiles []*scaf.File) (*MergeResult, error) {
    if len(inputFiles) != len(parsedFiles) {
        return nil, fmt.Errorf("inputFiles and parsedFiles length mismatch")
    }
    
    result := &MergeResult{
        File: &scaf.File{},
    }
    
    // Track sibling files for same-package import detection
    siblingBases := make(map[string]bool)
    for _, f := range inputFiles {
        base := filepath.Base(f)
        baseNoExt := base[:len(base)-len(filepath.Ext(base))]
        siblingBases[baseNoExt] = true
        siblingBases[base] = true
        siblingBases["./"+base] = true
        siblingBases["./"+baseNoExt] = true
    }
    
    // Track seen imports: key = "alias:resolvedPath"
    seenImports := make(map[string]bool)
    
    // Track function names to detect duplicates
    fnSources := make(map[string]string) // fnName -> sourceFile
    
    for i, suite := range parsedFiles {
        inputFile := inputFiles[i]
        
        // Process imports
        for _, imp := range suite.Imports {
            // Check if import points to sibling file
            if isSamePackageImport(imp.Path, siblingBases) {
                result.Warnings = append(result.Warnings, MergeWarning{
                    File:    inputFile,
                    Message: fmt.Sprintf("import %q points to same-package file (unnecessary)", imp.Path),
                })
                continue // Skip this import
            }
            
            // Deduplicate by alias + path
            key := imp.Alias + ":" + imp.Path
            if !seenImports[key] {
                seenImports[key] = true
                result.File.Imports = append(result.File.Imports, imp)
            }
        }
        
        // Process functions - check for duplicates
        for _, fn := range suite.Functions {
            if existingFile, exists := fnSources[fn.Name]; exists {
                return nil, fmt.Errorf("duplicate function %q: defined in %s and %s",
                    fn.Name, existingFile, inputFile)
            }
            fnSources[fn.Name] = inputFile
            result.File.Functions = append(result.File.Functions, fn)
        }
        
        // Merge scopes
        result.File.Scopes = append(result.File.Scopes, suite.Scopes...)
        
        // Setup/Teardown: keep first, warn on conflicts
        if suite.Setup != nil {
            if result.File.Setup != nil {
                result.Warnings = append(result.Warnings, MergeWarning{
                    File:    inputFile,
                    Message: "multiple setup clauses; using first, ignoring this one",
                })
            } else {
                result.File.Setup = suite.Setup
            }
        }
        if suite.Teardown != nil {
            if result.File.Teardown != nil {
                result.Warnings = append(result.Warnings, MergeWarning{
                    File:    inputFile,
                    Message: "multiple teardown clauses; using first, ignoring this one",
                })
            } else {
                result.File.Teardown = suite.Teardown
            }
        }
    }
    
    return result, nil
}

// isSamePackageImport checks if an import path points to a sibling file.
func isSamePackageImport(importPath string, siblingBases map[string]bool) bool {
    // Direct match
    if siblingBases[importPath] {
        return true
    }
    // Check base name
    base := filepath.Base(importPath)
    if siblingBases[base] {
        return true
    }
    // Check without extension
    baseNoExt := base[:len(base)-len(filepath.Ext(base))]
    return siblingBases[baseNoExt]
}
```

### 2. language/go/package.go (new file)

**Purpose**: Go-specific package name inference.

**Reference**: Discussion in T-019bb083-728f-70ce-9a30-5cdd1c2a1409 about `go/build.ImportDir`

```go
package golang

import (
    "go/build"
    "go/parser"
    "go/token"
    "os"
    "path/filepath"
    "strings"
    "unicode"
)

// InferPackageName determines the Go package name for a directory.
//
// Detection ladder (highest to lowest priority):
// 1. go/build.ImportDir - respects build tags, returns pkg.Name
// 2. parser.PackageClauseOnly - parses any .go file for "package X"
// 3. Sanitized folder name - fallback when no Go files exist
//
// Reference: go/build docs at https://pkg.go.dev/go/build
// Reference: go/parser docs at https://pkg.go.dev/go/parser
func InferPackageName(dir string) string {
    // Step 1: go/build.ImportDir (respects build tags)
    if p, err := build.Default.ImportDir(dir, 0); err == nil && p.Name != "" {
        return p.Name
    }
    
    // Step 2: Parse any .go file's package clause
    // Catches files hidden by build tags
    if name := parseAnyPackageClause(dir); name != "" {
        return name
    }
    
    // Step 3: Sanitize folder name
    return SanitizePackageName(filepath.Base(dir))
}

// parseAnyPackageClause scans .go files for package declarations.
// Skips _test.go files. Returns first found package name.
func parseAnyPackageClause(dir string) string {
    entries, err := os.ReadDir(dir)
    if err != nil {
        return ""
    }
    
    fset := token.NewFileSet()
    
    for _, e := range entries {
        name := e.Name()
        if e.IsDir() || !strings.HasSuffix(name, ".go") {
            continue
        }
        if strings.HasSuffix(name, "_test.go") {
            continue
        }
        
        f, err := parser.ParseFile(fset, filepath.Join(dir, name), nil, parser.PackageClauseOnly)
        if err == nil && f.Name != nil {
            return f.Name.Name
        }
    }
    return ""
}

// SanitizePackageName converts a string to a valid Go package name.
//
// Rules applied:
// - Lowercase
// - Remove hyphens, underscores, dots
// - Prefix with underscore if starts with digit
// - Avoid Go keywords
//
// Reference: Go spec https://go.dev/ref/spec#identifier
// Reference: Effective Go https://go.dev/doc/effective_go#package-names
func SanitizePackageName(name string) string {
    var b strings.Builder
    
    for _, r := range name {
        switch {
        case r >= 'a' && r <= 'z':
            b.WriteRune(r)
        case r >= 'A' && r <= 'Z':
            b.WriteRune(unicode.ToLower(r))
        case r >= '0' && r <= '9':
            b.WriteRune(r)
        // Skip hyphens, underscores, dots, etc.
        }
    }
    
    result := b.String()
    if result == "" {
        return "main"
    }
    
    // Can't start with digit
    if result[0] >= '0' && result[0] <= '9' {
        result = "pkg" + result
    }
    
    // Avoid Go keywords (simplified check)
    keywords := map[string]bool{
        "break": true, "case": true, "chan": true, "const": true,
        "continue": true, "default": true, "defer": true, "else": true,
        "fallthrough": true, "for": true, "func": true, "go": true,
        "goto": true, "if": true, "import": true, "interface": true,
        "map": true, "package": true, "range": true, "return": true,
        "select": true, "struct": true, "switch": true, "type": true,
        "var": true,
    }
    if keywords[result] {
        result = result + "pkg"
    }
    
    return result
}
```

### 3. cmd/scaf/generate.go updates

**Purpose**: Orchestration - delegate to module and language layers.

**Reference**: Current implementation at `cmd/scaf/generate.go:256-326`

```go
// Updated generateMergedFiles - delegates to module.MergePackageFiles
// and language/go.InferPackageName
func generateMergedFiles(outputDir string, inputFiles []string, opts *generateOptions) error {
    // Parse all files
    var parsedFiles []*scaf.File
    for _, inputFile := range inputFiles {
        data, err := os.ReadFile(inputFile)
        if err != nil {
            return fmt.Errorf("reading %s: %w", inputFile, err)
        }
        
        suite, err := scaf.Parse(data)
        if err != nil {
            return fmt.Errorf("parsing %s: %w", inputFile, err)
        }
        parsedFiles = append(parsedFiles, suite)
    }
    
    // Delegate merging to module layer
    mergeResult, err := module.MergePackageFiles(inputFiles, parsedFiles)
    if err != nil {
        return fmt.Errorf("merging files: %w", err)
    }
    
    // Print warnings
    for _, w := range mergeResult.Warnings {
        fmt.Fprintf(os.Stderr, "warning: %s: %s\n", w.File, w.Message)
    }
    
    // Delegate package naming to language layer
    packageName := opts.packageName
    if packageName == "" {
        packageName = golang.InferPackageName(outputDir)
    }
    
    // ... rest of generation using mergeResult.File ...
}
```

### 4. analysis/rules.go addition

**Purpose**: Semantic warning for same-package imports during analysis.

**Reference**: Current rules at `analysis/rules.go`

```go
// checkSamePackageImport warns when an import points to a sibling file.
// This is called during LSP analysis, not during generate (which handles it in merge).
//
// Reference: Current diagnostic emission at analysis/rules.go
func (a *Analyzer) checkSamePackageImport(file *scaf.File, filePath string) {
    dir := filepath.Dir(filePath)
    
    // Find sibling .scaf files
    siblings := make(map[string]bool)
    entries, _ := os.ReadDir(dir)
    for _, e := range entries {
        if !e.IsDir() && strings.HasSuffix(e.Name(), ".scaf") && e.Name() != filepath.Base(filePath) {
            base := e.Name()
            baseNoExt := base[:len(base)-5] // strip .scaf
            siblings[base] = true
            siblings[baseNoExt] = true
            siblings["./"+base] = true
            siblings["./"+baseNoExt] = true
        }
    }
    
    for _, imp := range file.Imports {
        if isSamePackageImport(imp.Path, siblings) {
            a.addDiagnostic(Diagnostic{
                Severity: Warning,
                Message:  fmt.Sprintf("importing %q from same package is unnecessary; functions are directly available", imp.Path),
                Span:     imp.Meta().Span,
            })
        }
    }
}
```

## Testing Strategy

### Unit Tests

1. **module/merge_test.go**:
   - Merge two files with no overlap
   - Merge with duplicate imports (should dedupe)
   - Merge with same-package import (should warn + skip)
   - Merge with duplicate function names (should error)
   - Merge with conflicting setup/teardown (should warn)

2. **language/go/package_test.go**:
   - Dir with Go files → parse package name
   - Dir with build-tag-hidden files → fallback to PackageClauseOnly
   - Dir with no Go files → sanitize folder name
   - Folder names with hyphens, dots, digits

### Integration Tests

1. **example/repro-multi-package/**:
   - Run `scaf generate internal/users/`
   - Verify `scaf.go` contains all functions from both files
   - Verify warning about same-package import
   - Verify `go build` succeeds

## File References

| File | Lines | What |
|------|-------|------|
| `cmd/scaf/generate.go` | 225-240 | Current grouping logic |
| `cmd/scaf/generate.go` | 256-281 | Current merge logic (to refactor) |
| `cmd/scaf/generate.go` | 283-292 | Current package naming (to move) |
| `module/loader.go` | 30-55 | Loader pattern to follow |
| `analysis/rules.go` | - | Diagnostic emission pattern |
| `ast.go` | 1-80 | File/Import/Function types |

## Checklist

- [ ] Create `module/merge.go` with `MergePackageFiles()`
- [ ] Create `module/merge_test.go`
- [ ] Create `language/go/package.go` with `InferPackageName()`
- [ ] Create `language/go/package_test.go`
- [ ] Update `cmd/scaf/generate.go` to use new functions
- [ ] Add same-package import warning to `analysis/rules.go`
- [ ] Verify `example/repro-multi-package/` works
- [ ] Run `go test ./...`
