// Code generated by scaf. DO NOT EDIT.

package db

import (
	"context"
	"github.com/rlch/neogo"
)

type createPostResult struct {
	ID      int
	Title   string
	Content string
}

type getPostByIdResult struct {
	ID         int
	Title      string
	Content    string
	AuthorName string
}

type getPostsByAuthorResult struct {
	ID      int
	Title   string
	Content string
}

type listPostsResult struct {
	ID         int
	Title      string
	AuthorName string
}

type updatePostResult struct {
	ID      int
	Title   string
	Content string
}

func CreatePost(ctx context.Context, db neogo.Driver, authorId int, id int, title string, content string, createdAt int) ([]*createPostResult, error) {
	return createPostImpl(ctx, db, authorId, id, title, content, createdAt)
}

var createPostImpl func(context.Context, neogo.Driver, int, int, string, string, int) ([]*createPostResult, error) = createPostProd

func createPostProd(ctx context.Context, db neogo.Driver, authorId int, id int, title string, content string, createdAt int) ([]*createPostResult, error) {
	var rowsID []int
	var rowsTitle []string
	var rowsContent []string
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $authorId})
	CREATE (p:Post {id: $id, title: $title, content: $content, createdAt: $createdAt})
	CREATE (u)-[:AUTHORED]->(p)
	RETURN p.id, p.title, p.content`).
		RunWithParams(ctx, map[string]any{"authorId": authorId, "id": id, "title": title, "content": content, "createdAt": createdAt}, "p.id", &rowsID, "p.title", &rowsTitle, "p.content", &rowsContent)
	if err != nil {
		return nil, err
	}
	results := make([]*createPostResult, len(rowsID))
	for i := range rowsID {
		results[i] = &createPostResult{
			ID:      rowsID[i],
			Title:   rowsTitle[i],
			Content: rowsContent[i],
		}
	}
	return results, nil
}

func GetPostById(ctx context.Context, db neogo.Driver, id int) ([]*getPostByIdResult, error) {
	return getPostByIdImpl(ctx, db, id)
}

var getPostByIdImpl func(context.Context, neogo.Driver, int) ([]*getPostByIdResult, error) = getPostByIdProd

func getPostByIdProd(ctx context.Context, db neogo.Driver, id int) ([]*getPostByIdResult, error) {
	var rowsID []int
	var rowsTitle []string
	var rowsContent []string
	var rowsAuthorName []string
	err := db.Exec().
		Cypher(`MATCH (p:Post {id: $id})
	OPTIONAL MATCH (author:User)-[:AUTHORED]->(p)
	RETURN p.id, p.title, p.content, author.name as authorName`).
		RunWithParams(ctx, map[string]any{"id": id}, "p.id", &rowsID, "p.title", &rowsTitle, "p.content", &rowsContent, "authorName", &rowsAuthorName)
	if err != nil {
		return nil, err
	}
	results := make([]*getPostByIdResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getPostByIdResult{
			ID:         rowsID[i],
			Title:      rowsTitle[i],
			Content:    rowsContent[i],
			AuthorName: rowsAuthorName[i],
		}
	}
	return results, nil
}

func GetPostsByAuthor(ctx context.Context, db neogo.Driver, authorId int) ([]*getPostsByAuthorResult, error) {
	return getPostsByAuthorImpl(ctx, db, authorId)
}

var getPostsByAuthorImpl func(context.Context, neogo.Driver, int) ([]*getPostsByAuthorResult, error) = getPostsByAuthorProd

func getPostsByAuthorProd(ctx context.Context, db neogo.Driver, authorId int) ([]*getPostsByAuthorResult, error) {
	var rowsID []int
	var rowsTitle []string
	var rowsContent []string
	err := db.Exec().
		Cypher(`MATCH (u:User {id: $authorId})-[:AUTHORED]->(p:Post)
	RETURN p.id, p.title, p.content
	ORDER BY p.createdAt DESC`).
		RunWithParams(ctx, map[string]any{"authorId": authorId}, "p.id", &rowsID, "p.title", &rowsTitle, "p.content", &rowsContent)
	if err != nil {
		return nil, err
	}
	results := make([]*getPostsByAuthorResult, len(rowsID))
	for i := range rowsID {
		results[i] = &getPostsByAuthorResult{
			ID:      rowsID[i],
			Title:   rowsTitle[i],
			Content: rowsContent[i],
		}
	}
	return results, nil
}

func ListPosts(ctx context.Context, db neogo.Driver) ([]*listPostsResult, error) {
	return listPostsImpl(ctx, db)
}

var listPostsImpl func(context.Context, neogo.Driver) ([]*listPostsResult, error) = listPostsProd

func listPostsProd(ctx context.Context, db neogo.Driver) ([]*listPostsResult, error) {
	var rowsID []int
	var rowsTitle []string
	var rowsAuthorName []string
	err := db.Exec().
		Cypher(`MATCH (p:Post)
	OPTIONAL MATCH (author:User)-[:AUTHORED]->(p)
	RETURN p.id, p.title, author.name as authorName
	ORDER BY p.createdAt DESC`).
		Run(ctx, "p.id", &rowsID, "p.title", &rowsTitle, "authorName", &rowsAuthorName)
	if err != nil {
		return nil, err
	}
	results := make([]*listPostsResult, len(rowsID))
	for i := range rowsID {
		results[i] = &listPostsResult{
			ID:         rowsID[i],
			Title:      rowsTitle[i],
			AuthorName: rowsAuthorName[i],
		}
	}
	return results, nil
}

func UpdatePost(ctx context.Context, db neogo.Driver, id int, title string, content string) ([]*updatePostResult, error) {
	return updatePostImpl(ctx, db, id, title, content)
}

var updatePostImpl func(context.Context, neogo.Driver, int, string, string) ([]*updatePostResult, error) = updatePostProd

func updatePostProd(ctx context.Context, db neogo.Driver, id int, title string, content string) ([]*updatePostResult, error) {
	var rowsID []int
	var rowsTitle []string
	var rowsContent []string
	err := db.Exec().
		Cypher(`MATCH (p:Post {id: $id})
	SET p.title = $title, p.content = $content
	RETURN p.id, p.title, p.content`).
		RunWithParams(ctx, map[string]any{"id": id, "title": title, "content": content}, "p.id", &rowsID, "p.title", &rowsTitle, "p.content", &rowsContent)
	if err != nil {
		return nil, err
	}
	results := make([]*updatePostResult, len(rowsID))
	for i := range rowsID {
		results[i] = &updatePostResult{
			ID:      rowsID[i],
			Title:   rowsTitle[i],
			Content: rowsContent[i],
		}
	}
	return results, nil
}

func DeletePost(ctx context.Context, db neogo.Driver, id int) ([]int, error) {
	return deletePostImpl(ctx, db, id)
}

var deletePostImpl func(context.Context, neogo.Driver, int) ([]int, error) = deletePostProd

func deletePostProd(ctx context.Context, db neogo.Driver, id int) ([]int, error) {
	var rowsDeleted []int
	err := db.Exec().
		Cypher(`MATCH (p:Post {id: $id})
	DETACH DELETE p
	RETURN count(p) as deleted`).
		RunWithParams(ctx, map[string]any{"id": id}, "deleted", &rowsDeleted)
	if err != nil {
		return nil, err
	}
	return rowsDeleted, nil
}

func CountPosts(ctx context.Context, db neogo.Driver) ([]int, error) {
	return countPostsImpl(ctx, db)
}

var countPostsImpl func(context.Context, neogo.Driver) ([]int, error) = countPostsProd

func countPostsProd(ctx context.Context, db neogo.Driver) ([]int, error) {
	var rowsCount []int
	err := db.Exec().
		Cypher(`MATCH (p:Post)
	RETURN count(p) as count`).
		Run(ctx, "count", &rowsCount)
	if err != nil {
		return nil, err
	}
	return rowsCount, nil
}

func CountRelationships(ctx context.Context, db neogo.Driver) ([]int, error) {
	return countRelationshipsImpl(ctx, db)
}

var countRelationshipsImpl func(context.Context, neogo.Driver) ([]int, error) = countRelationshipsProd

func countRelationshipsProd(ctx context.Context, db neogo.Driver) ([]int, error) {
	var rowsCount []int
	err := db.Exec().
		Cypher(`MATCH ()-[r:AUTHORED]->()
	RETURN count(r) as count`).
		Run(ctx, "count", &rowsCount)
	if err != nil {
		return nil, err
	}
	return rowsCount, nil
}
