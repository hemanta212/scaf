
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>scaf: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/rlch/scaf/ast.go (0.0%)</option>
				
				<option value="file1">github.com/rlch/scaf/config.go (0.0%)</option>
				
				<option value="file2">github.com/rlch/scaf/dialect.go (0.0%)</option>
				
				<option value="file3">github.com/rlch/scaf/format.go (0.0%)</option>
				
				<option value="file4">github.com/rlch/scaf/lexer.go (99.3%)</option>
				
				<option value="file5">github.com/rlch/scaf/parser.go (50.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package scaf provides a DSL parser for database test scaffolding.
package scaf

import (
        "fmt"
        "strconv"
        "strings"
)

// Suite represents a complete test file with queries, setup, teardown, and test scopes.
type Suite struct {
        Imports  []*Import     `parser:"@@*"`
        Queries  []*Query      `parser:"@@*"`
        Setup    *SetupClause  `parser:"('setup' @@)?"`
        Teardown *string       `parser:"('teardown' @RawString)?"`
        Scopes   []*QueryScope `parser:"@@*"`
}

// Import represents a module import statement.
// Examples:
//
//        import "../../setup/lesson_plan_db"
//        import fixtures "../shared/fixtures"
type Import struct {
        Alias *string `parser:"'import' @Ident?"`
        Path  string  `parser:"@String"`
}

// Query defines a named database query.
type Query struct {
        Name string `parser:"'query' @Ident"`
        Body string `parser:"@RawString"`
}

// SetupClause represents either an inline setup query or a named setup reference.
// Examples:
//
//        setup `CREATE (:User)`                              // inline
//        setup lesson_plan_db.SetupLessonPlanDB()            // named, no params
//        setup fixtures.CreatePosts($n: 10, $authorId: 1)    // named with params
type SetupClause struct {
        Inline *string     `parser:"@RawString"`
        Named  *NamedSetup `parser:"| @@"`
}

// NamedSetup references a setup defined elsewhere (local or imported).
// Examples:
//
//        SetupLessonPlanDB()
//        module.SetupName($param: value)
type NamedSetup struct {
        Module *string       `parser:"(@Ident Dot)?"`
        Name   string        `parser:"@Ident '('"`
        Params []*SetupParam `parser:"(@@ (Comma @@)*)? ')'"`
}

// SetupParam is a parameter passed to a named setup.
type SetupParam struct {
        Name  string `parser:"@Ident Colon"`
        Value *Value `parser:"@@"`
}

// QueryScope groups tests that target a specific query.
type QueryScope struct {
        QueryName string         `parser:"@Ident '{'"`
        Setup     *SetupClause   `parser:"('setup' @@)?"`
        Teardown  *string        `parser:"('teardown' @RawString)?"`
        Items     []*TestOrGroup `parser:"@@* '}'"`
}

// TestOrGroup is a union type - either a Test or a Group.
type TestOrGroup struct {
        Test  *Test  `parser:"@@"`
        Group *Group `parser:"| @@"`
}

// Group organizes related tests with optional shared setup and teardown.
type Group struct {
        Name     string         `parser:"'group' @String '{'"`
        Setup    *SetupClause   `parser:"('setup' @@)?"`
        Teardown *string        `parser:"('teardown' @RawString)?"`
        Items    []*TestOrGroup `parser:"@@* '}'"`
}

// Test defines a single test case with inputs, expected outputs, and optional assertions.
// Tests run in a transaction that rolls back after execution, so no teardown is needed.
type Test struct {
        Name       string       `parser:"'test' @String '{'"`
        Setup      *SetupClause `parser:"('setup' @@)?"`
        Statements []*Statement `parser:"@@*"`
        Asserts    []*Assert    `parser:"@@*"`
        Close      string       `parser:"'}'"`
}

// Assert represents an assertion block with optional query.
// Expressions are captured as tokens and reconstructed as strings for expr.Compile().
// Examples:
//
//        assert { u.age &gt; 18 }                                    // standalone expr
//        assert { x &gt; 0; y &lt; 10; z == 5 }                         // multiple exprs
//        assert CreatePost($title: "x") { p.title == "x" }        // named query with conditions
//        assert `MATCH (n) RETURN count(n) as cnt` { cnt &gt; 0 }    // inline query with conditions
type Assert struct {
        Query      *AssertQuery `parser:"'assert' @@? '{'"`
        Conditions []*Expr      `parser:"(@@ Semi?)* '}'"`
}

// AssertQuery specifies the query to run before evaluating conditions.
// Either an inline raw string query or a named query reference with params.
type AssertQuery struct {
        // Inline query (raw string)
        Inline *string `parser:"@RawString"`
        // Or named query reference with required parentheses
        QueryName *string       `parser:"| @Ident '('"`
        Params    []*SetupParam `parser:"(@@ (Comma @@)*)? ')'"`
}

// Expr captures tokens for expr-lang evaluation.
// Tokens are reconstructed into a string and parsed by expr.Compile() at runtime.
type Expr struct {
        Tokens []*ExprToken `parser:"@@+"`
}

// String reconstructs the expression as a string for expr-lang.
func (e *Expr) String() string <span class="cov0" title="0">{
        if e == nil || len(e.Tokens) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">var b strings.Builder
        for i, tok := range e.Tokens </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        prev := e.Tokens[i-1]
                        // Add space between tokens except:
                        // - around dots (u.name)
                        // - after open brackets (foo(x), arr[0])
                        // - before close brackets (foo(x), arr[0])
                        // - between identifier and open bracket (function calls: len(x))
                        // - after comma (we add space after comma below)
                        needsSpace := !prev.IsDot() &amp;&amp; !prev.IsOpenBracket() &amp;&amp; !prev.Comma &amp;&amp;
                                !tok.IsDot() &amp;&amp; !tok.IsCloseBracket() &amp;&amp;
                                !(prev.IsIdent() &amp;&amp; tok.IsOpenBracket())
                        if needsSpace </span><span class="cov0" title="0">{
                                b.WriteByte(' ')
                        }</span>
                }
                <span class="cov0" title="0">b.WriteString(tok.String())
                // Add space after comma
                if tok.Comma </span><span class="cov0" title="0">{
                        b.WriteByte(' ')
                }</span>
        }
        <span class="cov0" title="0">return b.String()</span>
}

// ExprToken captures individual tokens that can appear in expressions.
// Matches expr-lang's token kinds: Identifier, Number, String, Operator, Bracket.
// Note: { } ; are NOT captured as they're expression delimiters.
type ExprToken struct {
        Str     *string `parser:"@String"`
        Number  *string `parser:"| @Number"`
        Ident   *string `parser:"| @Ident"`
        Op      *string `parser:"| @Op"`
        Dot     bool    `parser:"| @Dot"`
        Colon   bool    `parser:"| @Colon"`
        Comma   bool    `parser:"| @Comma"`
        LParen  bool    `parser:"| @'('"`
        RParen  bool    `parser:"| @')'"`
        LBrack  bool    `parser:"| @'['"`
        RBrack  bool    `parser:"| @']'"`
}

// String returns the string representation of a token.
func (t *ExprToken) String() string <span class="cov0" title="0">{
        switch </span>{
        case t.Str != nil:<span class="cov0" title="0">
                return fmt.Sprintf("%q", *t.Str)</span>
        case t.Number != nil:<span class="cov0" title="0">
                return *t.Number</span>
        case t.Ident != nil:<span class="cov0" title="0">
                return *t.Ident</span>
        case t.Op != nil:<span class="cov0" title="0">
                return *t.Op</span>
        case t.Dot:<span class="cov0" title="0">
                return "."</span>
        case t.Colon:<span class="cov0" title="0">
                return ":"</span>
        case t.Comma:<span class="cov0" title="0">
                return ","</span>
        case t.LParen:<span class="cov0" title="0">
                return "("</span>
        case t.RParen:<span class="cov0" title="0">
                return ")"</span>
        case t.LBrack:<span class="cov0" title="0">
                return "["</span>
        case t.RBrack:<span class="cov0" title="0">
                return "]"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

// IsDot returns true if this token is a dot.
func (t *ExprToken) IsDot() bool <span class="cov0" title="0">{
        return t.Dot
}</span>

// IsOpenBracket returns true if this token is an opening bracket.
func (t *ExprToken) IsOpenBracket() bool <span class="cov0" title="0">{
        return t.LParen || t.LBrack
}</span>

// IsCloseBracket returns true if this token is a closing bracket.
func (t *ExprToken) IsCloseBracket() bool <span class="cov0" title="0">{
        return t.RParen || t.RBrack
}</span>

// IsIdent returns true if this token is an identifier.
func (t *ExprToken) IsIdent() bool <span class="cov0" title="0">{
        return t.Ident != nil
}</span>

// DottedIdent represents a dot-separated identifier like "u.name" or "$userId".
type DottedIdent struct {
        Parts []string `parser:"@Ident (Dot @Ident)*"`
}

// String returns the dot-joined identifier.
func (d *DottedIdent) String() string <span class="cov0" title="0">{
        return strings.Join(d.Parts, ".")
}</span>

// Statement represents a key-value pair for inputs ($var) or expected outputs.
// Examples:
//
//        $userId: 1                                    // input parameter
//        u.name: "Alice"                               // expected output (equality)
type Statement struct {
        KeyParts *DottedIdent `parser:"@@"`
        Value    *Value       `parser:"Colon @@"`
}

// Key returns the statement key as a dot-joined string.
func (s *Statement) Key() string <span class="cov0" title="0">{
        if s.KeyParts == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return s.KeyParts.String()</span>
}

// NewStatement creates a Statement from a dot-separated key string and value.
// This is a convenience constructor for testing and programmatic AST construction.
func NewStatement(key string, value *Value) *Statement <span class="cov0" title="0">{
        parts := strings.Split(key, ".")
        return &amp;Statement{
                KeyParts: &amp;DottedIdent{Parts: parts},
                Value:    value,
        }
}</span>

// Boolean is a bool type that implements participle's Capture interface.
type Boolean bool

// Capture implements participle's Capture interface for Boolean.
func (b *Boolean) Capture(values []string) error <span class="cov0" title="0">{
        *b = values[0] == "true"

        return nil
}</span>

// Value represents a literal value (string, number, bool, null, map, or list).
type Value struct {
        Null    bool     `parser:"@'null'"`
        Str     *string  `parser:"| @String"`
        Number  *float64 `parser:"| @Number"`
        Boolean *Boolean `parser:"| @('true' | 'false')"`
        Map     *Map     `parser:"| @@"`
        List    *List    `parser:"| @@"`
}

// Map represents a key-value map literal.
type Map struct {
        Entries []*MapEntry `parser:"'{' (@@ (Comma @@)*)? '}'"`
}

// MapEntry represents a single entry in a map literal.
type MapEntry struct {
        Key   string `parser:"@Ident Colon"`
        Value *Value `parser:"@@"`
}

// List represents an array/list literal.
type List struct {
        Values []*Value `parser:"'[' (@@ (Comma @@)*)? ']'"`
}

// ToGo converts a Value to a native Go type.
func (v *Value) ToGo() any <span class="cov0" title="0">{
        switch </span>{
        case v.Null:<span class="cov0" title="0">
                return nil</span>
        case v.Str != nil:<span class="cov0" title="0">
                return *v.Str</span>
        case v.Number != nil:<span class="cov0" title="0">
                return *v.Number</span>
        case v.Boolean != nil:<span class="cov0" title="0">
                return bool(*v.Boolean)</span>
        case v.Map != nil:<span class="cov0" title="0">
                m := make(map[string]any)
                for _, e := range v.Map.Entries </span><span class="cov0" title="0">{
                        m[e.Key] = e.Value.ToGo()
                }</span>

                <span class="cov0" title="0">return m</span>
        case v.List != nil:<span class="cov0" title="0">
                l := make([]any, len(v.List.Values))
                for i, val := range v.List.Values </span><span class="cov0" title="0">{
                        l[i] = val.ToGo()
                }</span>

                <span class="cov0" title="0">return l</span>
        default:<span class="cov0" title="0">
                return nil</span>
        }
}

// String returns a string representation of the Value.
func (v *Value) String() string <span class="cov0" title="0">{
        switch </span>{
        case v.Null:<span class="cov0" title="0">
                return "null"</span>
        case v.Str != nil:<span class="cov0" title="0">
                return fmt.Sprintf("%q", *v.Str)</span>
        case v.Number != nil:<span class="cov0" title="0">
                return fmt.Sprintf("%v", *v.Number)</span>
        case v.Boolean != nil:<span class="cov0" title="0">
                return strconv.FormatBool(bool(*v.Boolean))</span>
        case v.Map != nil:<span class="cov0" title="0">
                return v.mapString()</span>
        case v.List != nil:<span class="cov0" title="0">
                return v.listString()</span>
        default:<span class="cov0" title="0">
                return "nil"</span>
        }
}

func (v *Value) mapString() string <span class="cov0" title="0">{
        parts := make([]string, len(v.Map.Entries))
        for i, e := range v.Map.Entries </span><span class="cov0" title="0">{
                parts[i] = fmt.Sprintf("%s: %s", e.Key, e.Value)
        }</span>

        <span class="cov0" title="0">return "{" + strings.Join(parts, ", ") + "}"</span>
}

func (v *Value) listString() string <span class="cov0" title="0">{
        parts := make([]string, len(v.List.Values))
        for i, val := range v.List.Values </span><span class="cov0" title="0">{
                parts[i] = val.String()
        }</span>

        <span class="cov0" title="0">return "[" + strings.Join(parts, ", ") + "]"</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package scaf

import (
        "os"
        "path/filepath"

        "gopkg.in/yaml.v3"
)

// Config represents the .scaf.yaml configuration file.
type Config struct {
        // Default dialect for all .scaf files
        Dialect string `yaml:"dialect"`

        // Connection config for the default dialect
        Connection DialectConfig `yaml:"connection"`

        // Per-pattern overrides (glob pattern -&gt; dialect name)
        // e.g., "integration/*.scaf": "postgres"
        Files map[string]string `yaml:"files,omitempty"`
}

// DefaultConfigNames are the filenames we search for.
var DefaultConfigNames = []string{".scaf.yaml", ".scaf.yml", "scaf.yaml", "scaf.yml"}

// LoadConfig finds and loads the nearest .scaf.yaml walking up from dir.
func LoadConfig(dir string) (*Config, error) <span class="cov0" title="0">{
        path, err := FindConfig(dir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return LoadConfigFile(path)</span>
}

// FindConfig searches for a config file starting from dir and walking up.
func FindConfig(dir string) (string, error) <span class="cov0" title="0">{
        absDir, err := filepath.Abs(dir)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">for dir := absDir; ; </span><span class="cov0" title="0">{
                for _, name := range DefaultConfigNames </span><span class="cov0" title="0">{
                        path := filepath.Join(dir, name)

                        _, err := os.Stat(path)
                        if err == nil </span><span class="cov0" title="0">{
                                return path, nil
                        }</span>
                }

                <span class="cov0" title="0">parent := filepath.Dir(dir)
                if parent == dir </span><span class="cov0" title="0">{
                        return "", ErrConfigNotFound
                }</span>

                <span class="cov0" title="0">dir = parent</span>
        }
}

// LoadConfigFile loads a config from a specific path.
func LoadConfigFile(path string) (*Config, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(filepath.Clean(path))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var cfg Config

        err = yaml.Unmarshal(data, &amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;cfg, nil</span>
}

// DialectFor returns the dialect name for a given file path.
// It checks file-specific patterns first, then falls back to the default.
func (c *Config) DialectFor(filePath string) string <span class="cov0" title="0">{
        for pattern, dialect := range c.Files </span><span class="cov0" title="0">{
                if matched, _ := filepath.Match(pattern, filePath); matched </span><span class="cov0" title="0">{
                        return dialect
                }</span>
        }

        <span class="cov0" title="0">return c.Dialect</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package scaf

import (
        "context"
        "fmt"
)

// Dialect defines the interface for database backends.
type Dialect interface {
        // Name returns the dialect identifier (e.g., "neo4j", "postgres").
        Name() string

        // Execute runs a query with parameters and returns the results.
        Execute(ctx context.Context, query string, params map[string]any) ([]map[string]any, error)

        // Close releases any resources held by the dialect.
        Close() error
}

// Transaction represents an active database transaction.
// Queries executed through a transaction are isolated until Commit or Rollback.
type Transaction interface {
        // Execute runs a query within this transaction.
        Execute(ctx context.Context, query string, params map[string]any) ([]map[string]any, error)

        // Commit commits the transaction.
        Commit(ctx context.Context) error

        // Rollback aborts the transaction.
        Rollback(ctx context.Context) error
}

// Transactional is an optional interface for dialects that support transactions.
// The runner uses this for test isolation (rollback after each test).
type Transactional interface {
        Dialect

        // Begin starts a new transaction.
        Begin(ctx context.Context) (Transaction, error)
}

// DialectFactory creates a Dialect from connection configuration.
type DialectFactory func(cfg DialectConfig) (Dialect, error)

// DialectConfig holds connection settings for a dialect.
type DialectConfig struct {
        // Connection URI (e.g., "bolt://localhost:7687", "postgres://localhost/db")
        URI string `yaml:"uri"`

        // Optional credentials (if not in URI)
        Username string `yaml:"username,omitempty"`
        Password string `yaml:"password,omitempty"`

        // Dialect-specific options
        Options map[string]any `yaml:"options,omitempty"`
}

var dialects = make(map[string]DialectFactory)

// RegisterDialect registers a dialect factory by name.
func RegisterDialect(name string, factory DialectFactory) <span class="cov0" title="0">{
        dialects[name] = factory
}</span>

// NewDialect creates a dialect instance by name.
func NewDialect(name string, cfg DialectConfig) (*dialectWrapper, error) <span class="cov0" title="0">{
        factory, ok := dialects[name]
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: %s", ErrUnknownDialect, name)
        }</span>

        <span class="cov0" title="0">d, err := factory(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;dialectWrapper{d}, nil</span>
}

// dialectWrapper wraps a Dialect to return concrete type.
type dialectWrapper struct {
        Dialect
}

// Begin delegates to the underlying dialect if it supports transactions.
func (w *dialectWrapper) Begin(ctx context.Context) (Transaction, error) <span class="cov0" title="0">{
        if tx, ok := w.Dialect.(Transactional); ok </span><span class="cov0" title="0">{
                return tx.Begin(ctx)
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("dialect does not support transactions")</span>
}

// Transactional returns true if the underlying dialect supports transactions.
func (w *dialectWrapper) Transactional() bool <span class="cov0" title="0">{
        _, ok := w.Dialect.(Transactional)
        return ok
}</span>

// RegisteredDialects returns the names of all registered dialects.
func RegisteredDialects() []string <span class="cov0" title="0">{
        names := make([]string, 0, len(dialects))
        for name := range dialects </span><span class="cov0" title="0">{
                names = append(names, name)
        }</span>

        <span class="cov0" title="0">return names</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package scaf

import (
        "strconv"
        "strings"
)

// Format formats a Suite AST back into scaf DSL source code.
func Format(s *Suite) string <span class="cov0" title="0">{
        var b strings.Builder

        f := &amp;formatter{b: &amp;b, indent: 0}
        f.formatSuite(s)

        return strings.TrimSpace(b.String()) + "\n"
}</span>

type formatter struct {
        b      *strings.Builder
        indent int
}

func (f *formatter) write(s string) <span class="cov0" title="0">{
        f.b.WriteString(s)
}</span>

func (f *formatter) writeLine(s string) <span class="cov0" title="0">{
        f.writeIndent()
        f.write(s)
        f.write("\n")
}</span>

func (f *formatter) writeIndent() <span class="cov0" title="0">{
        for range f.indent </span><span class="cov0" title="0">{
                f.write("\t")
        }</span>
}

func (f *formatter) blankLine() <span class="cov0" title="0">{
        f.write("\n")
}</span>

func (f *formatter) formatSuite(s *Suite) <span class="cov0" title="0">{
        // Imports
        for _, imp := range s.Imports </span><span class="cov0" title="0">{
                f.formatImport(imp)
        }</span>

        // Queries
        <span class="cov0" title="0">for i, q := range s.Queries </span><span class="cov0" title="0">{
                if i &gt; 0 || len(s.Imports) &gt; 0 </span><span class="cov0" title="0">{
                        f.blankLine()
                }</span>

                <span class="cov0" title="0">f.formatQuery(q)</span>
        }

        // Global setup
        <span class="cov0" title="0">if s.Setup != nil </span><span class="cov0" title="0">{
                if len(s.Queries) &gt; 0 || len(s.Imports) &gt; 0 </span><span class="cov0" title="0">{
                        f.blankLine()
                }</span>

                <span class="cov0" title="0">f.formatSetupClause(s.Setup)</span>
        }

        // Global teardown
        <span class="cov0" title="0">if s.Teardown != nil </span><span class="cov0" title="0">{
                f.formatTeardown(*s.Teardown)
        }</span>

        // Scopes
        <span class="cov0" title="0">for i, scope := range s.Scopes </span><span class="cov0" title="0">{
                if i &gt; 0 || len(s.Queries) &gt; 0 || len(s.Imports) &gt; 0 || s.Setup != nil || s.Teardown != nil </span><span class="cov0" title="0">{
                        f.blankLine()
                }</span>

                <span class="cov0" title="0">f.formatScope(scope)</span>
        }
}

func (f *formatter) formatImport(imp *Import) <span class="cov0" title="0">{
        if imp.Alias != nil </span><span class="cov0" title="0">{
                f.writeLine("import " + *imp.Alias + " " + f.quotedString(imp.Path))
        }</span> else<span class="cov0" title="0"> {
                f.writeLine("import " + f.quotedString(imp.Path))
        }</span>
}

func (f *formatter) formatQuery(q *Query) <span class="cov0" title="0">{
        f.writeLine("query " + q.Name + " " + f.rawString(q.Body))
}</span>

func (f *formatter) formatSetupClause(s *SetupClause) <span class="cov0" title="0">{
        if s.Inline != nil </span><span class="cov0" title="0">{
                f.writeLine("setup " + f.rawString(*s.Inline))
        }</span> else<span class="cov0" title="0"> if s.Named != nil </span><span class="cov0" title="0">{
                f.formatNamedSetup(s.Named)
        }</span>
}

func (f *formatter) formatNamedSetup(ns *NamedSetup) <span class="cov0" title="0">{
        var b strings.Builder
        b.WriteString("setup ")

        if ns.Module != nil </span><span class="cov0" title="0">{
                b.WriteString(*ns.Module)
                b.WriteString(".")
        }</span>

        <span class="cov0" title="0">b.WriteString(ns.Name)
        b.WriteString("(")

        for i, p := range ns.Params </span><span class="cov0" title="0">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        b.WriteString(", ")
                }</span>
                <span class="cov0" title="0">b.WriteString(p.Name)
                b.WriteString(": ")
                b.WriteString(f.formatValue(p.Value))</span>
        }

        <span class="cov0" title="0">b.WriteString(")")
        f.writeLine(b.String())</span>
}

func (f *formatter) formatTeardown(body string) <span class="cov0" title="0">{
        f.writeLine("teardown " + f.rawString(body))
}</span>

func (f *formatter) formatScope(s *QueryScope) <span class="cov0" title="0">{
        f.writeLine(s.QueryName + " {")
        f.indent++

        if s.Setup != nil </span><span class="cov0" title="0">{
                f.formatSetupClause(s.Setup)
        }</span>

        <span class="cov0" title="0">if s.Teardown != nil </span><span class="cov0" title="0">{
                f.formatTeardown(*s.Teardown)
        }</span>

        <span class="cov0" title="0">f.formatItems(s.Items, s.Setup != nil || s.Teardown != nil)

        f.indent--
        f.writeLine("}")</span>
}

func (f *formatter) formatItems(items []*TestOrGroup, hasSetupOrTeardown bool) <span class="cov0" title="0">{
        for i, item := range items </span><span class="cov0" title="0">{
                needsBlank := i &gt; 0 || hasSetupOrTeardown

                if item.Test != nil </span><span class="cov0" title="0">{
                        if needsBlank </span><span class="cov0" title="0">{
                                f.blankLine()
                        }</span>

                        <span class="cov0" title="0">f.formatTest(item.Test)</span>
                } else<span class="cov0" title="0"> if item.Group != nil </span><span class="cov0" title="0">{
                        if needsBlank </span><span class="cov0" title="0">{
                                f.blankLine()
                        }</span>

                        <span class="cov0" title="0">f.formatGroup(item.Group)</span>
                }
        }
}

func (f *formatter) formatGroup(g *Group) <span class="cov0" title="0">{
        f.writeLine("group " + f.quotedString(g.Name) + " {")
        f.indent++

        if g.Setup != nil </span><span class="cov0" title="0">{
                f.formatSetupClause(g.Setup)
        }</span>

        <span class="cov0" title="0">if g.Teardown != nil </span><span class="cov0" title="0">{
                f.formatTeardown(*g.Teardown)
        }</span>

        <span class="cov0" title="0">f.formatItems(g.Items, g.Setup != nil || g.Teardown != nil)

        f.indent--
        f.writeLine("}")</span>
}

func (f *formatter) formatTest(t *Test) <span class="cov0" title="0">{
        f.writeLine("test " + f.quotedString(t.Name) + " {")
        f.indent++

        if t.Setup != nil </span><span class="cov0" title="0">{
                f.formatSetupClause(t.Setup)
        }</span>

        // Separate inputs from outputs
        <span class="cov0" title="0">var inputs, outputs []*Statement

        for _, stmt := range t.Statements </span><span class="cov0" title="0">{
                if strings.HasPrefix(stmt.Key(), "$") </span><span class="cov0" title="0">{
                        inputs = append(inputs, stmt)
                }</span> else<span class="cov0" title="0"> {
                        outputs = append(outputs, stmt)
                }</span>
        }

        // Format inputs
        <span class="cov0" title="0">for i, stmt := range inputs </span><span class="cov0" title="0">{
                if i == 0 &amp;&amp; t.Setup != nil </span><span class="cov0" title="0">{
                        f.blankLine()
                }</span>

                <span class="cov0" title="0">f.formatStatement(stmt)</span>
        }

        // Format outputs with blank line separator from inputs
        <span class="cov0" title="0">for i, stmt := range outputs </span><span class="cov0" title="0">{
                if i == 0 &amp;&amp; len(inputs) &gt; 0 </span><span class="cov0" title="0">{
                        f.blankLine()
                }</span>

                <span class="cov0" title="0">f.formatStatement(stmt)</span>
        }

        // Assertions
        <span class="cov0" title="0">for i, a := range t.Asserts </span><span class="cov0" title="0">{
                if i == 0 &amp;&amp; (len(t.Statements) &gt; 0 || t.Setup != nil) </span><span class="cov0" title="0">{
                        f.blankLine()
                }</span>

                <span class="cov0" title="0">f.formatAssert(a)</span>
        }

        <span class="cov0" title="0">f.indent--
        f.writeLine("}")</span>
}

func (f *formatter) formatStatement(s *Statement) <span class="cov0" title="0">{
        f.writeLine(s.Key() + ": " + f.formatValue(s.Value))
}</span>

func (f *formatter) formatAssert(a *Assert) <span class="cov0" title="0">{
        var queryPart string
        if a.Query != nil </span><span class="cov0" title="0">{
                if a.Query.Inline != nil </span><span class="cov0" title="0">{
                        queryPart = f.rawString(*a.Query.Inline) + " "
                }</span> else<span class="cov0" title="0"> if a.Query.QueryName != nil </span><span class="cov0" title="0">{
                        queryPart = *a.Query.QueryName
                        if len(a.Query.Params) &gt; 0 </span><span class="cov0" title="0">{
                                var params []string
                                for _, p := range a.Query.Params </span><span class="cov0" title="0">{
                                        params = append(params, p.Name+": "+f.formatValue(p.Value))
                                }</span>
                                <span class="cov0" title="0">queryPart += "(" + strings.Join(params, ", ") + ") "</span>
                        } else<span class="cov0" title="0"> {
                                queryPart += "() "
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(a.Conditions) == 0 </span><span class="cov0" title="0">{
                f.writeLine("assert " + queryPart + "{}")
                return
        }</span>

        <span class="cov0" title="0">if len(a.Conditions) == 1 </span><span class="cov0" title="0">{
                f.writeLine("assert " + queryPart + "{ " + a.Conditions[0].String() + " }")
                return
        }</span>

        <span class="cov0" title="0">f.writeLine("assert " + queryPart + "{")
        f.indent++

        for i, cond := range a.Conditions </span><span class="cov0" title="0">{
                if i &lt; len(a.Conditions)-1 </span><span class="cov0" title="0">{
                        f.writeLine(cond.String() + ";")
                }</span> else<span class="cov0" title="0"> {
                        f.writeLine(cond.String())
                }</span>
        }

        <span class="cov0" title="0">f.indent--
        f.writeLine("}")</span>
}

func (f *formatter) formatValue(v *Value) string <span class="cov0" title="0">{
        switch </span>{
        case v.Null:<span class="cov0" title="0">
                return "null"</span>
        case v.Str != nil:<span class="cov0" title="0">
                return f.quotedString(*v.Str)</span>
        case v.Number != nil:<span class="cov0" title="0">
                return f.formatNumber(*v.Number)</span>
        case v.Boolean != nil:<span class="cov0" title="0">
                return strconv.FormatBool(bool(*v.Boolean))</span>
        case v.Map != nil:<span class="cov0" title="0">
                return f.formatMap(v.Map)</span>
        case v.List != nil:<span class="cov0" title="0">
                return f.formatList(v.List)</span>
        default:<span class="cov0" title="0">
                return "null"</span>
        }
}

func (f *formatter) formatNumber(n float64) string <span class="cov0" title="0">{
        if n == float64(int64(n)) </span><span class="cov0" title="0">{
                return strconv.FormatInt(int64(n), 10)
        }</span>

        <span class="cov0" title="0">return strconv.FormatFloat(n, 'f', -1, 64)</span>
}

func (f *formatter) formatMap(m *Map) string <span class="cov0" title="0">{
        if len(m.Entries) == 0 </span><span class="cov0" title="0">{
                return "{}"
        }</span>

        <span class="cov0" title="0">parts := make([]string, len(m.Entries))
        for i, e := range m.Entries </span><span class="cov0" title="0">{
                parts[i] = e.Key + ": " + f.formatValue(e.Value)
        }</span>

        <span class="cov0" title="0">return "{" + strings.Join(parts, ", ") + "}"</span>
}

func (f *formatter) formatList(l *List) string <span class="cov0" title="0">{
        if len(l.Values) == 0 </span><span class="cov0" title="0">{
                return "[]"
        }</span>

        <span class="cov0" title="0">parts := make([]string, len(l.Values))
        for i, v := range l.Values </span><span class="cov0" title="0">{
                parts[i] = f.formatValue(v)
        }</span>

        <span class="cov0" title="0">return "[" + strings.Join(parts, ", ") + "]"</span>
}

func (f *formatter) rawString(s string) string <span class="cov0" title="0">{
        return "`" + s + "`"
}</span>

func (f *formatter) quotedString(s string) string <span class="cov0" title="0">{
        return `"` + s + `"`
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package scaf

import (
        "io"
        "strings"
        "unicode"
        "unicode/utf8"

        "github.com/alecthomas/participle/v2/lexer"
)

// Token type constants - negative values as per participle convention.
const (
        tEOF        lexer.TokenType = lexer.EOF
        tComment    lexer.TokenType = -(iota + 2) //nolint:mnd // participle convention
        tRawString                                // backtick strings
        tString                                   // quoted strings
        tNumber                                   // all number formats
        tIdent                                    // identifiers including $-prefixed
        tOp                                       // operators
        tDot                                      // .
        tColon                                    // :
        tComma                                    // ,
        tSemi                                     // ;
        tLParen                                   // (
        tRParen                                   // )
        tLBracket                                 // [
        tRBracket                                 // ]
        tLBrace                                   // {
        tRBrace                                   // }
        tWhitespace                               // spaces, tabs, newlines
)

// Lexer errors.
var (
        ErrUnterminatedRawString = &amp;LexerError{msg: "unterminated raw string"}
        ErrUnterminatedString    = &amp;LexerError{msg: "unterminated string"}
        ErrUnexpectedCharacter   = &amp;LexerError{msg: "unexpected character"}
)

// LexerError represents a lexer error with position.
type LexerError struct {
        msg string
        pos lexer.Position
        ch  rune
}

func (e *LexerError) Error() string <span class="cov1" title="2">{
        if e.ch != 0 </span><span class="cov1" title="1">{
                return e.pos.String() + ": " + e.msg + ": " + string(e.ch)
        }</span>

        <span class="cov1" title="1">return e.pos.String() + ": " + e.msg</span>
}

func (e *LexerError) withPos(pos lexer.Position) *LexerError <span class="cov3" title="7">{
        return &amp;LexerError{msg: e.msg, pos: pos, ch: e.ch}
}</span>

func (e *LexerError) withChar(ch rune) *LexerError <span class="cov1" title="2">{
        return &amp;LexerError{msg: e.msg, pos: e.pos, ch: ch}
}</span>

// dslDefinition implements lexer.Definition for the scaf DSL.
type dslDefinition struct {
        symbols map[string]lexer.TokenType
}

// newDSLLexer creates a new lexer Definition for the scaf DSL.
func newDSLLexer() *dslDefinition <span class="cov1" title="1">{
        return &amp;dslDefinition{
                symbols: map[string]lexer.TokenType{
                        "EOF":        tEOF,
                        "Comment":    tComment,
                        "RawString":  tRawString,
                        "String":     tString,
                        "Number":     tNumber,
                        "Ident":      tIdent,
                        "Op":         tOp,
                        "Dot":        tDot,
                        "Colon":      tColon,
                        "Comma":      tComma,
                        "Semi":       tSemi,
                        "Whitespace": tWhitespace,
                        // Individual bracket tokens for grammar rules
                        "(": tLParen,
                        ")": tRParen,
                        "[": tLBracket,
                        "]": tRBracket,
                        "{": tLBrace,
                        "}": tRBrace,
                },
        }
}</span>

// Symbols returns the mapping of symbol names to token types.
func (d *dslDefinition) Symbols() map[string]lexer.TokenType <span class="cov6" title="128">{
        return d.symbols
}</span>

// Lex creates a new Lexer for the given reader.
func (d *dslDefinition) Lex(filename string, r io.Reader) (lexer.Lexer, error) <span class="cov6" title="92">{
        data, err := io.ReadAll(r)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov6" title="91">return d.LexBytes(filename, data)</span>
}

// LexBytes implements lexer.BytesDefinition for efficiency.
func (d *dslDefinition) LexBytes(filename string, data []byte) (lexer.Lexer, error) <span class="cov6" title="92">{
        return newLexerState(filename, string(data)), nil
}</span>

// LexString implements lexer.StringDefinition for efficiency.
func (d *dslDefinition) LexString(filename string, input string) (lexer.Lexer, error) <span class="cov1" title="1">{
        return newLexerState(filename, input), nil
}</span>

// lexerState holds the state for lexing.
type lexerState struct {
        filename string
        input    string
        offset   int
        line     int
        col      int
}

func newLexerState(filename, input string) *lexerState <span class="cov6" title="93">{
        return &amp;lexerState{
                filename: filename,
                input:    input,
                offset:   0,
                line:     1,
                col:      1,
        }
}</span>

// Next returns the next token.
func (l *lexerState) Next() (lexer.Token, error) <span class="cov7" title="269">{
        if l.eof() </span><span class="cov6" title="86">{
                return lexer.EOFToken(l.pos()), nil
        }</span>

        <span class="cov7" title="183">start := l.pos()
        r := l.peek()

        // Whitespace
        if isSpace(r) </span><span class="cov5" title="33">{
                for !l.eof() &amp;&amp; isSpace(l.peek()) </span><span class="cov5" title="39">{
                        l.advance()
                }</span>

                <span class="cov5" title="33">return l.token(tWhitespace, start), nil</span>
        }

        // Comment
        <span class="cov6" title="150">if r == '/' &amp;&amp; l.peekAt(1) == '/' </span><span class="cov2" title="3">{
                for !l.eof() &amp;&amp; l.peek() != '\n' </span><span class="cov4" title="29">{
                        l.advance()
                }</span>

                <span class="cov2" title="3">return l.token(tComment, start), nil</span>
        }

        // Raw string
        <span class="cov6" title="147">if r == '`' </span><span class="cov2" title="5">{
                return l.scanRawString(start)
        }</span>

        // String
        <span class="cov6" title="142">if r == '"' || r == '\'' </span><span class="cov3" title="10">{
                return l.scanString(start, r)
        }</span>

        // Number
        <span class="cov6" title="132">if isDigit(r) </span><span class="cov4" title="25">{
                return l.scanNumber(start), nil
        }</span>

        // Identifier
        <span class="cov6" title="107">if isIdentStart(r) </span><span class="cov5" title="41">{
                l.advance() // consume first char

                for !l.eof() &amp;&amp; isIdentContinue(l.peek()) </span><span class="cov6" title="81">{
                        l.advance()
                }</span>

                <span class="cov5" title="41">return l.token(tIdent, start), nil</span>
        }

        // Multi-character operators (check before single-char)
        <span class="cov5" title="66">if tok, ok := l.scanMultiCharOp(start); ok </span><span class="cov4" title="16">{
                return tok, nil
        }</span>

        // Single character tokens
        <span class="cov5" title="50">l.advance()

        switch r </span>{
        case '.':<span class="cov2" title="5">
                return l.token(tDot, start), nil</span>
        case ':':<span class="cov2" title="4">
                return l.token(tColon, start), nil</span>
        case ',':<span class="cov1" title="2">
                return l.token(tComma, start), nil</span>
        case ';':<span class="cov1" title="2">
                return l.token(tSemi, start), nil</span>
        case '(':<span class="cov1" title="2">
                return l.token(tLParen, start), nil</span>
        case ')':<span class="cov1" title="2">
                return l.token(tRParen, start), nil</span>
        case '[':<span class="cov1" title="2">
                return l.token(tLBracket, start), nil</span>
        case ']':<span class="cov1" title="2">
                return l.token(tRBracket, start), nil</span>
        case '{':<span class="cov2" title="4">
                return l.token(tLBrace, start), nil</span>
        case '}':<span class="cov2" title="4">
                return l.token(tRBrace, start), nil</span>
        }

        // Single-character operators
        <span class="cov4" title="21">if strings.ContainsRune("+-*/%^&amp;|!&lt;&gt;=?#~", r) </span><span class="cov4" title="19">{
                return l.token(tOp, start), nil
        }</span>

        <span class="cov1" title="2">return lexer.Token{}, ErrUnexpectedCharacter.withPos(start).withChar(r)</span>
}

func (l *lexerState) pos() lexer.Position <span class="cov7" title="269">{
        return lexer.Position{
                Filename: l.filename,
                Offset:   l.offset,
                Line:     l.line,
                Column:   l.col,
        }
}</span>

func (l *lexerState) eof() bool <span class="cov10" title="1972">{
        return l.offset &gt;= len(l.input)
}</span>

func (l *lexerState) peek() rune <span class="cov8" title="716">{
        if l.eof() </span><span class="cov4" title="22">{
                return 0
        }</span>

        <span class="cov8" title="694">r, _ := utf8.DecodeRuneInString(l.input[l.offset:])

        return r</span>
}

func (l *lexerState) peekAt(n int) rune <span class="cov5" title="33">{
        off := l.offset + n
        if off &gt;= len(l.input) </span><span class="cov1" title="2">{
                return 0
        }</span>

        <span class="cov5" title="31">r, _ := utf8.DecodeRuneInString(l.input[off:])

        return r</span>
}

func (l *lexerState) advance() rune <span class="cov8" title="518">{
        if l.eof() </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="518">r, size := utf8.DecodeRuneInString(l.input[l.offset:])
        l.offset += size

        if r == '\n' </span><span class="cov2" title="5">{
                l.line++
                l.col = 1
        }</span> else<span class="cov8" title="513"> {
                l.col++
        }</span>

        <span class="cov8" title="518">return r</span>
}

func (l *lexerState) match(s string) bool <span class="cov8" title="699">{
        return strings.HasPrefix(l.input[l.offset:], s)
}</span>

func (l *lexerState) token(typ lexer.TokenType, start lexer.Position) lexer.Token <span class="cov7" title="176">{
        return lexer.Token{
                Type:  typ,
                Value: l.input[start.Offset:l.offset],
                Pos:   start,
        }
}</span>

func (l *lexerState) scanRawString(start lexer.Position) (lexer.Token, error) <span class="cov2" title="5">{
        l.advance() // opening `

        for !l.eof() </span><span class="cov5" title="61">{
                if l.peek() == '`' </span><span class="cov2" title="4">{
                        l.advance() // closing `

                        return l.token(tRawString, start), nil
                }</span>

                <span class="cov5" title="57">l.advance()</span>
        }

        <span class="cov1" title="1">return lexer.Token{}, ErrUnterminatedRawString.withPos(start)</span>
}

func (l *lexerState) scanString(start lexer.Position, quote rune) (lexer.Token, error) <span class="cov3" title="10">{
        l.advance() // opening quote

        for !l.eof() </span><span class="cov6" title="76">{
                ch := l.peek()
                if ch == '\\' &amp;&amp; l.peekAt(1) != 0 </span><span class="cov1" title="2">{
                        l.advance() // backslash
                        l.advance() // escaped char

                        continue</span>
                }

                <span class="cov6" title="74">if ch == quote </span><span class="cov3" title="6">{
                        l.advance() // closing quote

                        return l.token(tString, start), nil
                }</span>

                <span class="cov6" title="68">if ch == '\n' </span><span class="cov1" title="1">{
                        return lexer.Token{}, ErrUnterminatedString.withPos(start)
                }</span>

                <span class="cov5" title="67">l.advance()</span>
        }

        <span class="cov2" title="3">return lexer.Token{}, ErrUnterminatedString.withPos(start)</span>
}

func (l *lexerState) scanMultiCharOp(start lexer.Position) (lexer.Token, bool) <span class="cov5" title="66">{
        multiOps := []string{"&amp;&amp;", "||", "==", "!=", "&lt;=", "&gt;=", "!~", "?.", "..", "?:", "::", "##"}

        for _, op := range multiOps </span><span class="cov8" title="699">{
                if l.match(op) </span><span class="cov4" title="16">{
                        for range len(op) </span><span class="cov5" title="32">{
                                l.advance()
                        }</span>

                        <span class="cov4" title="16">return l.token(tOp, start), true</span>
                }
        }

        <span class="cov5" title="50">return lexer.Token{}, false</span>
}

func (l *lexerState) scanNumber(start lexer.Position) lexer.Token <span class="cov4" title="25">{
        // Check for hex, octal, binary
        if l.peek() == '0' &amp;&amp; l.peekAt(1) != 0 </span><span class="cov3" title="11">{
                next := l.peekAt(1)

                switch </span>{
                case next == 'x' || next == 'X':<span class="cov2" title="3">
                        l.advance() // 0
                        l.advance() // x

                        for !l.eof() &amp;&amp; (isHexDigit(l.peek()) || l.peek() == '_') </span><span class="cov3" title="9">{
                                l.advance()
                        }</span>

                        <span class="cov2" title="3">return l.token(tNumber, start)</span>

                case next == 'o' || next == 'O':<span class="cov1" title="2">
                        l.advance() // 0
                        l.advance() // o

                        for !l.eof() &amp;&amp; (isOctalDigit(l.peek()) || l.peek() == '_') </span><span class="cov3" title="6">{
                                l.advance()
                        }</span>

                        <span class="cov1" title="2">return l.token(tNumber, start)</span>

                case next == 'b' || next == 'B':<span class="cov1" title="2">
                        l.advance() // 0
                        l.advance() // b

                        for !l.eof() &amp;&amp; (l.peek() == '0' || l.peek() == '1' || l.peek() == '_') </span><span class="cov3" title="8">{
                                l.advance()
                        }</span>

                        <span class="cov1" title="2">return l.token(tNumber, start)</span>
                }
        }

        // Decimal digits
        <span class="cov4" title="18">for !l.eof() &amp;&amp; (isDigit(l.peek()) || l.peek() == '_') </span><span class="cov5" title="34">{
                l.advance()
        }</span>

        // Fractional part
        <span class="cov4" title="18">if l.peek() == '.' &amp;&amp; isDigit(l.peekAt(1)) </span><span class="cov2" title="4">{
                l.advance() // .

                for !l.eof() &amp;&amp; (isDigit(l.peek()) || l.peek() == '_') </span><span class="cov3" title="6">{
                        l.advance()
                }</span>
        }

        // Exponent
        <span class="cov4" title="18">if l.peek() == 'e' || l.peek() == 'E' </span><span class="cov2" title="4">{
                l.advance() // e/E

                if l.peek() == '+' || l.peek() == '-' </span><span class="cov1" title="2">{
                        l.advance()
                }</span>

                <span class="cov2" title="4">for !l.eof() &amp;&amp; (isDigit(l.peek()) || l.peek() == '_') </span><span class="cov3" title="6">{
                        l.advance()
                }</span>
        }

        <span class="cov4" title="18">return l.token(tNumber, start)</span>
}

// Character helpers.

func isSpace(r rune) bool <span class="cov7" title="254">{
        return r == ' ' || r == '\t' || r == '\n' || r == '\r'
}</span>

func isDigit(r rune) bool <span class="cov7" title="205">{
        return r &gt;= '0' &amp;&amp; r &lt;= '9'
}</span>

func isHexDigit(r rune) bool <span class="cov3" title="9">{
        return isDigit(r) || (r &gt;= 'a' &amp;&amp; r &lt;= 'f') || (r &gt;= 'A' &amp;&amp; r &lt;= 'F')
}</span>

func isOctalDigit(r rune) bool <span class="cov3" title="6">{
        return r &gt;= '0' &amp;&amp; r &lt;= '7'
}</span>

func isIdentStart(r rune) bool <span class="cov6" title="107">{
        return r == '$' || r == '_' || unicode.IsLetter(r)
}</span>

func isIdentContinue(r rune) bool <span class="cov6" title="107">{
        return r == '_' || unicode.IsLetter(r) || unicode.IsDigit(r)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package scaf

import (
        "github.com/alecthomas/participle/v2"
)

// dslLexer is the custom lexer for the scaf DSL.
// Implements lexer.Definition interface for full control over tokenization.
var dslLexer = newDSLLexer()

var parser = participle.MustBuild[Suite](
        participle.Lexer(dslLexer),
        participle.Unquote("RawString", "String"),
        participle.Elide("Whitespace", "Comment"),
)

// Parse parses a scaf DSL file and returns the resulting Suite AST.
func Parse(data []byte) (*Suite, error) <span class="cov0" title="0">{
        return parser.ParseBytes("", data)
}</span>

// ExportedLexer returns the lexer definition for testing purposes.
func ExportedLexer() *dslDefinition <span class="cov10" title="91">{
        return dslLexer
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
