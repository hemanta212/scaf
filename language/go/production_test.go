package golang

import (
	"errors"
	"testing"

	"github.com/rlch/scaf"
	"github.com/rlch/scaf/language"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	// Import cypher dialect to register the analyzer
	_ "github.com/rlch/scaf/dialects/cypher"
)

// testBinding is a mock binding for testing.
type testBinding struct{}

func (t *testBinding) Name() string {
	return "test"
}

func (t *testBinding) Imports() []string {
	return []string{"github.com/example/db"}
}

func (t *testBinding) ReceiverType() string {
	return "" // No receiver for test binding
}

func (t *testBinding) PrependParams() []BindingParam {
	return nil // No prepend params for test binding
}

func (t *testBinding) ReturnsError() bool {
	return false // No error return for test binding
}

func (t *testBinding) GenerateBody(ctx *BodyContext) (string, error) {
	return "return db.Query(ctx, query)", nil
}

func TestGenerateRequiresBinding(t *testing.T) {
	t.Parallel()

	input := `
query GetUser ` + "`" + `
MATCH (u:User {id: $userId})
RETURN u.name AS name
` + "`" + `
`
	suite, err := scaf.Parse([]byte(input))
	require.NoError(t, err)

	analyzer := scaf.GetAnalyzer("cypher")

	ctx := &Context{
		GenerateContext: language.GenerateContext{
			Suite:         suite,
			QueryAnalyzer: analyzer,
		},
		PackageName: "testpkg",
		Binding:     nil, // No binding
	}

	lang := New()
	_, err = lang.GenerateWithContext(ctx)
	require.Error(t, err)
	assert.True(t, errors.Is(err, ErrNoBinding), "expected ErrNoBinding, got: %v", err)
}

func TestGenerateProductionFileMultipleReturns(t *testing.T) {
	t.Parallel()

	input := `
query GetUser ` + "`" + `
MATCH (u:User {id: $userId})
RETURN u.name AS name, u.age AS age
` + "`" + `
`
	suite, err := scaf.Parse([]byte(input))
	require.NoError(t, err)

	analyzer := scaf.GetAnalyzer("cypher")

	ctx := &Context{
		GenerateContext: language.GenerateContext{
			Suite:         suite,
			QueryAnalyzer: analyzer,
		},
		PackageName: "testpkg",
		Binding:     &testBinding{},
	}

	gen := &generator{ctx: ctx}
	signatures, err := gen.extractSignatures()
	require.NoError(t, err)

	content, err := gen.generateProductionFile(signatures)
	require.NoError(t, err)
	require.NotNil(t, content)

	// With multiple returns, we generate a result struct
	expected := `// Code generated by scaf. DO NOT EDIT.

package testpkg

import (
	"github.com/example/db"
)

type getUserResult struct {
	Name any
	Age any
}

func GetUser(userId any) []*getUserResult {
	return getUserImpl(userId)
}

var getUserImpl func(any) []*getUserResult = getUserProd

func getUserProd(userId any) []*getUserResult {
	return db.Query(ctx, query)
}
`
	assert.Equal(t, expected, string(content))
}

func TestGenerateProductionFileMultipleFunctions(t *testing.T) {
	t.Parallel()

	input := `
query GetUser ` + "`" + `
MATCH (u:User {id: $userId})
RETURN u.name AS name
` + "`" + `

query GetPost ` + "`" + `
MATCH (p:Post {id: $postId})
RETURN p.title AS title
` + "`" + `
`
	suite, err := scaf.Parse([]byte(input))
	require.NoError(t, err)

	analyzer := scaf.GetAnalyzer("cypher")

	ctx := &Context{
		GenerateContext: language.GenerateContext{
			Suite:         suite,
			QueryAnalyzer: analyzer,
		},
		PackageName: "testpkg",
		Binding:     &testBinding{},
	}

	gen := &generator{ctx: ctx}
	signatures, err := gen.extractSignatures()
	require.NoError(t, err)

	content, err := gen.generateProductionFile(signatures)
	require.NoError(t, err)
	require.NotNil(t, content)

	expected := `// Code generated by scaf. DO NOT EDIT.

package testpkg

import (
	"github.com/example/db"
)

func GetUser(userId any) []any {
	return getUserImpl(userId)
}

var getUserImpl func(any) []any = getUserProd

func getUserProd(userId any) []any {
	return db.Query(ctx, query)
}

func GetPost(postId any) []any {
	return getPostImpl(postId)
}

var getPostImpl func(any) []any = getPostProd

func getPostProd(postId any) []any {
	return db.Query(ctx, query)
}
`
	assert.Equal(t, expected, string(content))
}

func TestGenerateProductionFileNoParams(t *testing.T) {
	t.Parallel()

	input := `
query CountUsers ` + "`" + `
MATCH (u:User)
RETURN count(u) AS count
` + "`" + `
`
	suite, err := scaf.Parse([]byte(input))
	require.NoError(t, err)

	analyzer := scaf.GetAnalyzer("cypher")

	ctx := &Context{
		GenerateContext: language.GenerateContext{
			Suite:         suite,
			QueryAnalyzer: analyzer,
		},
		PackageName: "testpkg",
		Binding:     &testBinding{},
	}

	gen := &generator{ctx: ctx}
	signatures, err := gen.extractSignatures()
	require.NoError(t, err)

	content, err := gen.generateProductionFile(signatures)
	require.NoError(t, err)
	require.NotNil(t, content)

	expected := `// Code generated by scaf. DO NOT EDIT.

package testpkg

import (
	"github.com/example/db"
)

func CountUsers() []any {
	return countUsersImpl()
}

var countUsersImpl func() []any = countUsersProd

func countUsersProd() []any {
	return db.Query(ctx, query)
}
`
	assert.Equal(t, expected, string(content))
}

func TestGenerateProductionFileNilSuite(t *testing.T) {
	t.Parallel()

	ctx := &Context{
		GenerateContext: language.GenerateContext{
			Suite: nil,
		},
		PackageName: "testpkg",
		Binding:     &testBinding{},
	}

	gen := &generator{ctx: ctx}
	content, err := gen.generateProductionFile(nil)
	require.NoError(t, err)
	assert.Nil(t, content)
}

func TestGenerateProductionFileNoReturns(t *testing.T) {
	t.Parallel()

	input := `
query DeleteUser ` + "`" + `
MATCH (u:User {id: $userId})
DELETE u
` + "`" + `
`
	suite, err := scaf.Parse([]byte(input))
	require.NoError(t, err)

	analyzer := scaf.GetAnalyzer("cypher")

	ctx := &Context{
		GenerateContext: language.GenerateContext{
			Suite:         suite,
			QueryAnalyzer: analyzer,
		},
		PackageName: "testpkg",
		Binding:     &testBinding{},
	}

	gen := &generator{ctx: ctx}
	signatures, err := gen.extractSignatures()
	require.NoError(t, err)

	content, err := gen.generateProductionFile(signatures)
	require.NoError(t, err)
	require.NotNil(t, content)

	expected := `// Code generated by scaf. DO NOT EDIT.

package testpkg

import (
	"github.com/example/db"
)

func DeleteUser(userId any) {
	deleteUserImpl(userId)
}

var deleteUserImpl func(any) = deleteUserProd

func deleteUserProd(userId any) {
	return db.Query(ctx, query)
}
`
	assert.Equal(t, expected, string(content))
}
